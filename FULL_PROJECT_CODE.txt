
========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\BusinessLayer\Exceptions\NotFoundException.cs ==========
namespace BusinessLayer.Exceptions
{
    public class NotFoundException : Exception
    {
        public NotFoundException(string message) : base(message)
        {
        }

        public NotFoundException(string message, Exception innerException)
            : base(message, innerException)
        {
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\BusinessLayer\Exceptions\UnauthorizedException.cs ==========
namespace BusinessLayer.Exceptions
{
    public class UnauthorizedException : Exception
    {
        public UnauthorizedException(string message) : base(message)
        {
        }

        public UnauthorizedException(string message, Exception innerException)
            : base(message, innerException)
        {
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\BusinessLayer\Exceptions\ValidationException.cs ==========
namespace BusinessLayer.Exceptions
{
    public class ValidationException : Exception
    {
        public ValidationException(string message) : base(message)
        {
        }

        public ValidationException(string message, Exception innerException)
            : base(message, innerException)
        {
        }

        public Dictionary<string, string[]>? Errors { get; set; }

        public ValidationException(Dictionary<string, string[]> errors)
            : base("Validation failed")
        {
            Errors = errors;
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\BusinessLayer\Interfaces\Services\IAuthService.cs ==========
using ModelLayer.DTOs.Auth;

namespace BusinessLayer.Interfaces.Services
{
    public interface IAuthService
    {
        Task<string> RegisterAsync(RegisterRequestDto dto);
        Task VerifyOtpAsync(string email, string otp);
        Task<AuthResponseDto> LoginAsync(LoginRequestDto dto);
        Task<AuthResponseDto> RefreshTokenAsync(string refreshToken);
        Task ForgotPasswordAsync(string email);
        Task ResetPasswordAsync(ResetPasswordDto dto);
        Task LogoutAsync(int userId);
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\BusinessLayer\Interfaces\Services\ICollaboratorService.cs ==========
using ModelLayer.DTOs.Collaborators;

namespace BusinessLayer.Interfaces.Services
{
    public interface ICollaboratorService
    {
        Task<IEnumerable<CollaboratorResponseDto>> GetByNoteIdAsync(int noteId, int userId);
        Task<CollaboratorResponseDto> AddAsync(AddCollaboratorDto dto, int ownerUserId);
        Task<CollaboratorResponseDto> UpdatePermissionAsync(int collaboratorId, UpdatePermissionDto dto, int ownerUserId);
        Task RemoveAsync(int collaboratorId, int ownerUserId);
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\BusinessLayer\Interfaces\Services\ILabelService.cs ==========
using ModelLayer.DTOs.Labels;

namespace BusinessLayer.Interfaces.Services
{
    public interface ILabelService
    {
        Task<IEnumerable<LabelResponseDto>> GetByUserAsync(int userId);
        Task<LabelResponseDto?> GetByIdAsync(int labelId, int userId);
        Task<LabelResponseDto> CreateAsync(CreateLabelDto dto, int userId);
        Task<LabelResponseDto> UpdateAsync(int labelId, UpdateLabelDto dto, int userId);
        Task DeleteAsync(int labelId, int userId);
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\BusinessLayer\Interfaces\Services\INoteService.cs ==========
using ModelLayer.DTOs.Notes;

namespace BusinessLayer.Interfaces.Services
{
    public interface INoteService
    {
        Task<IEnumerable<NoteResponseDto>> GetAllAsync(int userId);
        Task<NoteResponseDto?> GetByIdAsync(int noteId, int userId);
        Task<NoteResponseDto> CreateAsync(CreateNoteDto dto, int userId);
        Task<NoteResponseDto> UpdateAsync(int noteId, UpdateNoteDto dto, int userId);
        Task DeleteAsync(int noteId, int userId);
        Task BulkDeleteAsync(BulkDeleteDto dto, int userId);
        Task<IEnumerable<NoteResponseDto>> SearchAsync(SearchNotesDto dto, int userId);
        Task<NoteResponseDto> TogglePinAsync(int noteId, int userId);
        Task<NoteResponseDto> ToggleArchiveAsync(int noteId, int userId);
        Task<NoteResponseDto> UpdateColorAsync(int noteId, UpdateNoteColorDto dto, int userId);
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\BusinessLayer\Rules\CollaboratorRules.cs ==========
using BusinessLayer.Exceptions;
using ModelLayer.Enums;

namespace BusinessLayer.Rules
{
    public static class CollaboratorRules
    {
        public static void ValidatePermission(PermissionLevel permission)
        {
            if (!Enum.IsDefined(typeof(PermissionLevel), permission))
                throw new ValidationException("Invalid permission level");
        }

        public static void ValidateNoteId(int noteId)
        {
            if (noteId <= 0)
                throw new ValidationException("Invalid note ID");
        }

        public static void ValidateUserId(int userId)
        {
            if (userId <= 0)
                throw new ValidationException("Invalid user ID");
        }

        public static void ValidateCollaboratorId(int collaboratorId)
        {
            if (collaboratorId <= 0)
                throw new ValidationException("Invalid collaborator ID");
        }

        public static void ValidateAddCollaborator(int noteId, int userId, PermissionLevel permission)
        {
            ValidateNoteId(noteId);
            ValidateUserId(userId);
            ValidatePermission(permission);
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\BusinessLayer\Rules\LabelRules.cs ==========
using BusinessLayer.Exceptions;
using System.Text.RegularExpressions;

namespace BusinessLayer.Rules
{
    public static partial class LabelRules
    {
        public static void ValidateName(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
                throw new ValidationException("Label name is required");

            // Trim whitespace
            name = name.Trim();

            if (name.Length < 1)
                throw new ValidationException("Label name must be at least 1 character long");

            if (name.Length > 50)
                throw new ValidationException("Label name cannot exceed 50 characters");

            // Check for valid characters (letters, numbers, spaces, hyphens, underscores)
            if (!IsValidLabelName(name))
                throw new ValidationException("Label name contains invalid characters. Only letters, numbers, spaces, hyphens, and underscores are allowed");

            // Prevent labels with only whitespace after trim
            if (string.IsNullOrWhiteSpace(name))
                throw new ValidationException("Label name cannot be only whitespace");
        }

        public static void ValidateNameLength(string name, int minLength, int maxLength)
        {
            if (string.IsNullOrWhiteSpace(name))
                throw new ValidationException("Label name is required");

            var trimmedName = name.Trim();

            if (trimmedName.Length < minLength)
                throw new ValidationException($"Label name must be at least {minLength} characters long");

            if (trimmedName.Length > maxLength)
                throw new ValidationException($"Label name cannot exceed {maxLength} characters");
        }

        private static bool IsValidLabelName(string name)
        {
            // Allow letters (any language), numbers, spaces, hyphens, and underscores
            var regex = LabelNameRegex();
            return regex.IsMatch(name);
        }

        [GeneratedRegex(@"^[\w\s\-]+$", RegexOptions.None)]
        private static partial Regex LabelNameRegex();
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\BusinessLayer\Rules\NoteRules.cs ==========
using BusinessLayer.Exceptions;
using ModelLayer.DTOs.Notes;
using System.Text.RegularExpressions;

namespace BusinessLayer.Rules
{
    public static partial class NoteRules
    {
        private static readonly string[] ValidColors = new[]
        {
            "#FFFFFF", // White (Default)
            "#F28B82", // Red
            "#FBBC04", // Orange
            "#FFF475", // Yellow
            "#CCFF90", // Green
            "#A7FFEB", // Teal
            "#CBF0F8", // Cyan
            "#AECBFA", // Blue
            "#D7AEFB", // Purple
            "#FDCFE8", // Pink
            "#E6C9A8", // Brown
            "#E8EAED"  // Gray
        };

        public static void ValidateCreate(CreateNoteDto dto)
        {
            // At least title or content is required
            if (string.IsNullOrWhiteSpace(dto.Title) && string.IsNullOrWhiteSpace(dto.Content))
                throw new ValidationException("Either title or content is required");

            // Validate title if provided
            if (!string.IsNullOrWhiteSpace(dto.Title))
            {
                if (dto.Title.Length > 200)
                    throw new ValidationException("Title cannot exceed 200 characters");

                // Check for excessive whitespace
                if (dto.Title.Trim().Length == 0)
                    throw new ValidationException("Title cannot be only whitespace");
            }

            // Validate content if provided
            if (!string.IsNullOrWhiteSpace(dto.Content))
            {
                if (dto.Content.Length > 10000)
                    throw new ValidationException("Content cannot exceed 10,000 characters");
            }

            // Validate color if provided
            if (!string.IsNullOrWhiteSpace(dto.Color))
            {
                ValidateColor(dto.Color);
            }
        }

        public static void ValidateUpdate(UpdateNoteDto dto)
        {
            // Validate title if provided
            if (dto.Title != null)
            {
                if (dto.Title.Length > 200)
                    throw new ValidationException("Title cannot exceed 200 characters");

                if (dto.Title.Trim().Length == 0)
                    throw new ValidationException("Title cannot be only whitespace");
            }

            // Validate content if provided
            if (dto.Content != null)
            {
                if (dto.Content.Length > 10000)
                    throw new ValidationException("Content cannot exceed 10,000 characters");
            }
        }

        public static void ValidateColor(string color)
        {
            if (string.IsNullOrWhiteSpace(color))
                throw new ValidationException("Color is required");

            // Trim and uppercase for comparison
            color = color.Trim().ToUpper();

            // Check if it's a valid hex color format
            if (!IsValidHexColor(color))
                throw new ValidationException("Invalid color format. Use hex format (e.g., #FFFFFF)");

            // Check if it's one of the allowed colors
            if (!ValidColors.Contains(color))
                throw new ValidationException($"Color must be one of the predefined colors: {string.Join(", ", ValidColors)}");
        }

        public static void ValidateSearchQuery(string query)
        {
            if (string.IsNullOrWhiteSpace(query))
                throw new ValidationException("Search query cannot be empty");

            if (query.Length > 200)
                throw new ValidationException("Search query cannot exceed 200 characters");

            // Remove excessive whitespace
            query = query.Trim();

            if (query.Length < 2)
                throw new ValidationException("Search query must be at least 2 characters long");
        }

        public static void ValidateBulkDelete(IEnumerable<int> noteIds)
        {
            if (noteIds == null || !noteIds.Any())
                throw new ValidationException("At least one note ID is required");

            if (noteIds.Count() > 100)
                throw new ValidationException("Cannot delete more than 100 notes at once");

            // Check for duplicate IDs
            if (noteIds.Distinct().Count() != noteIds.Count())
                throw new ValidationException("Duplicate note IDs are not allowed");

            // Check for invalid IDs (negative or zero)
            if (noteIds.Any(id => id <= 0))
                throw new ValidationException("Invalid note ID detected");
        }

        private static bool IsValidHexColor(string color)
        {
            var regex = HexColorRegex();
            return regex.IsMatch(color);
        }

        [GeneratedRegex(@"^#([A-Fa-f0-9]{6})$")]
        private static partial Regex HexColorRegex();
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\BusinessLayer\Rules\UserRules.cs ==========
using BusinessLayer.Exceptions;
using ModelLayer.DTOs.Auth;
using System.Text.RegularExpressions;

namespace BusinessLayer.Rules
{
    public static partial class UserRules
    {
        public static void ValidateRegistration(RegisterRequestDto dto)
        {
            // Name validation
            if (string.IsNullOrWhiteSpace(dto.Name))
                throw new ValidationException("Name is required");

            if (dto.Name.Length < 2)
                throw new ValidationException("Name must be at least 2 characters long");

            if (dto.Name.Length > 100)
                throw new ValidationException("Name cannot exceed 100 characters");

            // Only allow letters, spaces, and basic punctuation
            if (!IsValidName(dto.Name))
                throw new ValidationException("Name contains invalid characters");

            // Email validation
            if (string.IsNullOrWhiteSpace(dto.Email))
                throw new ValidationException("Email is required");

            if (!IsValidEmail(dto.Email))
                throw new ValidationException("Invalid email format");

            if (dto.Email.Length > 255)
                throw new ValidationException("Email cannot exceed 255 characters");

            // Password validation
            ValidatePassword(dto.Password);
        }

        public static void ValidatePassword(string password)
        {
            if (string.IsNullOrWhiteSpace(password))
                throw new ValidationException("Password is required");

            if (password.Length < 6)
                throw new ValidationException("Password must be at least 6 characters long");

            if (password.Length > 100)
                throw new ValidationException("Password cannot exceed 100 characters");

            // Check for at least one uppercase letter
            if (!password.Any(char.IsUpper))
                throw new ValidationException("Password must contain at least one uppercase letter");

            // Check for at least one lowercase letter
            if (!password.Any(char.IsLower))
                throw new ValidationException("Password must contain at least one lowercase letter");

            // Check for at least one digit
            if (!password.Any(char.IsDigit))
                throw new ValidationException("Password must contain at least one number");

            // Optional: Check for special character
            // if (!password.Any(c => "!@#$%^&*()_+-=[]{}|;:,.<>?".Contains(c)))
            //     throw new ValidationException("Password must contain at least one special character");
        }

        public static void ValidateEmail(string email)
        {
            if (string.IsNullOrWhiteSpace(email))
                throw new ValidationException("Email is required");

            if (!IsValidEmail(email))
                throw new ValidationException("Invalid email format");
        }

        private static bool IsValidEmail(string email)
        {
            if (string.IsNullOrWhiteSpace(email))
                return false;

            try
            {
                var regex = EmailRegex();
                return regex.IsMatch(email);
            }
            catch
            {
                return false;
            }
        }

        private static bool IsValidName(string name)
        {
            // Allow letters, spaces, hyphens, apostrophes, and periods
            var regex = NameRegex();
            return regex.IsMatch(name);
        }

        [GeneratedRegex(@"^[^@\s]+@[^@\s]+\.[^@\s]+$", RegexOptions.IgnoreCase)]
        private static partial Regex EmailRegex();

        [GeneratedRegex(@"^[a-zA-Z\s\-'.]+$")]
        private static partial Regex NameRegex();
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\BusinessLayer\Services\AuthService.cs ==========
// ========================================
// FILE: BusinessLayer/Services/AuthService.cs (COMPLETE & FIXED)
// ========================================
using BusinessLayer.Exceptions;
using BusinessLayer.Interfaces.Services;
using BusinessLayer.Rules;
using DataBaseLayer.Entities;
using DataBaseLayer.Interfaces;
using ModelLayer.DTOs.Auth;
using System.Security.Cryptography;

namespace BusinessLayer.Services
{
    public class AuthService : IAuthService
    {
        private readonly IUserRepository _userRepository;

        public AuthService(IUserRepository userRepository)
        {
            _userRepository = userRepository;
        }

        public async Task<string> RegisterAsync(RegisterRequestDto dto)
        {
            // Validate input
            UserRules.ValidateRegistration(dto);

            // Check if user already exists
            var existingUser = await _userRepository.GetByEmailAsync(dto.Email);
            if (existingUser != null)
                throw new ValidationException("User with this email already exists");

            // Generate OTP
            var otp = GenerateOtp();

            // Create new user
            var user = new User
            {
                Name = dto.Name,
                Email = dto.Email,
                PasswordHash = BCrypt.Net.BCrypt.HashPassword(dto.Password),
                EmailVerificationToken = otp,
                EmailVerificationExpiry = DateTime.UtcNow.AddMinutes(10),
                IsEmailVerified = false,
                CreatedAt = DateTime.UtcNow
            };

            await _userRepository.AddAsync(user);
            await _userRepository.SaveAsync();

            return otp;
        }

        public async Task VerifyOtpAsync(string email, string otp)
        {
            if (string.IsNullOrWhiteSpace(email))
                throw new ValidationException("Email is required");

            if (string.IsNullOrWhiteSpace(otp))
                throw new ValidationException("OTP is required");

            var user = await _userRepository.GetByEmailAsync(email)
                ?? throw new NotFoundException("User not found");

            if (user.EmailVerificationToken != otp)
                throw new ValidationException("Invalid OTP");

            if (user.EmailVerificationExpiry < DateTime.UtcNow)
                throw new ValidationException("OTP has expired");

            // Verify email
            user.IsEmailVerified = true;
            user.EmailVerificationToken = null;
            user.EmailVerificationExpiry = null;

            await _userRepository.SaveAsync();
        }

        public async Task<AuthResponseDto> LoginAsync(LoginRequestDto dto)
        {
            if (string.IsNullOrWhiteSpace(dto.Email))
                throw new ValidationException("Email is required");

            if (string.IsNullOrWhiteSpace(dto.Password))
                throw new ValidationException("Password is required");

            var user = await _userRepository.GetByEmailAsync(dto.Email)
                ?? throw new UnauthorizedException("Invalid credentials");

            // Check account lockout
            if (user.LockoutEnd.HasValue && user.LockoutEnd > DateTime.UtcNow)
            {
                var remainingTime = (user.LockoutEnd.Value - DateTime.UtcNow).Minutes;
                throw new UnauthorizedException($"Account is locked. Try again in {remainingTime} minutes");
            }

            // Verify password
            if (!BCrypt.Net.BCrypt.Verify(dto.Password, user.PasswordHash))
            {
                // Increment failed login attempts
                user.FailedLoginAttempts++;

                if (user.FailedLoginAttempts >= 5)
                {
                    user.LockoutEnd = DateTime.UtcNow.AddMinutes(15);
                    user.FailedLoginAttempts = 0;
                    await _userRepository.SaveAsync();
                    throw new UnauthorizedException("Too many failed login attempts. Account locked for 15 minutes");
                }

                await _userRepository.SaveAsync();
                throw new UnauthorizedException("Invalid credentials");
            }

            // Check if email is verified
            if (!user.IsEmailVerified)
                throw new UnauthorizedException("Email not verified. Please verify your email first");

            // Reset failed login attempts
            user.FailedLoginAttempts = 0;
            user.LockoutEnd = null;
            user.LastLoginAt = DateTime.UtcNow;

            // Generate refresh token
            var refreshToken = GenerateRefreshToken();
            user.RefreshToken = refreshToken;
            user.RefreshTokenExpiry = DateTime.UtcNow.AddDays(7);

            await _userRepository.SaveAsync();

            return new AuthResponseDto
            {
                UserId = user.Id,
                Email = user.Email,
                RefreshToken = refreshToken,
                ExpiresIn = 3600
            };
        }

        public async Task<AuthResponseDto> RefreshTokenAsync(string refreshToken)
        {
            if (string.IsNullOrWhiteSpace(refreshToken))
                throw new ValidationException("Refresh token is required");

            var user = await _userRepository.GetByRefreshTokenAsync(refreshToken)
                ?? throw new UnauthorizedException("Invalid refresh token");

            if (user.RefreshTokenExpiry < DateTime.UtcNow)
                throw new UnauthorizedException("Refresh token has expired");

            // Generate new refresh token
            var newRefreshToken = GenerateRefreshToken();
            user.RefreshToken = newRefreshToken;
            user.RefreshTokenExpiry = DateTime.UtcNow.AddDays(7);

            await _userRepository.SaveAsync();

            return new AuthResponseDto
            {
                UserId = user.Id,
                Email = user.Email,
                RefreshToken = newRefreshToken,
                ExpiresIn = 3600
            };
        }

        public async Task ForgotPasswordAsync(string email)
        {
            if (string.IsNullOrWhiteSpace(email))
                throw new ValidationException("Email is required");

            var user = await _userRepository.GetByEmailAsync(email);

            // Don't reveal if email exists (security best practice)
            if (user == null)
                return;

            // Generate reset token
            var resetToken = GenerateResetToken();
            user.PasswordResetToken = resetToken; // ✅ FIXED
            user.PasswordResetExpiry = DateTime.UtcNow.AddMinutes(15); // ✅ FIXED

            await _userRepository.SaveAsync();

            // In production, send email with reset link containing token
            // await _emailService.SendPasswordResetEmailAsync(user.Email, resetToken);
        }

        public async Task ResetPasswordAsync(ResetPasswordDto dto)
        {
            if (string.IsNullOrWhiteSpace(dto.Token))
                throw new ValidationException("Reset token is required");

            if (string.IsNullOrWhiteSpace(dto.NewPassword))
                throw new ValidationException("New password is required");

            // Validate new password
            UserRules.ValidatePassword(dto.NewPassword);

            var user = await _userRepository.GetByResetTokenAsync(dto.Token)
                ?? throw new ValidationException("Invalid or expired reset token");

            if (user.PasswordResetExpiry < DateTime.UtcNow) // ✅ FIXED: Was "user.Pass"
                throw new ValidationException("Password reset token has expired");

            // Update password
            user.PasswordHash = BCrypt.Net.BCrypt.HashPassword(dto.NewPassword);
            user.PasswordResetToken = null; // ✅ FIXED
            user.PasswordResetExpiry = null; // ✅ FIXED

            // Invalidate all refresh tokens for security
            user.RefreshToken = null;
            user.RefreshTokenExpiry = null;

            await _userRepository.SaveAsync();
        }

        public async Task LogoutAsync(int userId)
        {
            var user = await _userRepository.GetByIdAsync(userId)
                ?? throw new NotFoundException("User not found");

            // Invalidate refresh token
            user.RefreshToken = null;
            user.RefreshTokenExpiry = null;

            await _userRepository.SaveAsync();
        }

        // Helper method to generate 6-digit OTP
        private static string GenerateOtp()
        {
            return Random.Shared.Next(100000, 999999).ToString();
        }

        // Helper method to generate secure refresh token
        private static string GenerateRefreshToken()
        {
            var randomBytes = new byte[32];
            using var rng = RandomNumberGenerator.Create();
            rng.GetBytes(randomBytes);
            return Convert.ToBase64String(randomBytes);
        }

        // Helper method to generate password reset token
        private static string GenerateResetToken()
        {
            return Guid.NewGuid().ToString("N");
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\BusinessLayer\Services\CollaboratorService.cs ==========
using BusinessLayer.Exceptions;
using BusinessLayer.Interfaces.Services;
using DataBaseLayer.Entities;
using DataBaseLayer.Interfaces;
using ModelLayer.DTOs.Collaborators;

namespace BusinessLayer.Services
{
    public class CollaboratorService : ICollaboratorService
    {
        private readonly ICollaboratorRepository _collaboratorRepository;
        private readonly INoteRepository _noteRepository;
        private readonly IUserRepository _userRepository;

        public CollaboratorService(
            ICollaboratorRepository collaboratorRepository,
            INoteRepository noteRepository,
            IUserRepository userRepository)
        {
            _collaboratorRepository = collaboratorRepository;
            _noteRepository = noteRepository;
            _userRepository = userRepository;
        }

        public async Task<IEnumerable<CollaboratorResponseDto>> GetByNoteIdAsync(int noteId, int userId)
        {
            var note = await _noteRepository.GetByIdAsync(noteId)
                ?? throw new NotFoundException("Note not found");

            // Only owner and collaborators can view collaborators list
            if (note.UserId != userId && !await _collaboratorRepository.ExistsAsync(noteId, userId))
                throw new UnauthorizedException("Access denied");

            var collaborators = await _collaboratorRepository.GetByNoteIdAsync(noteId);

            return collaborators.Select(c => new CollaboratorResponseDto
            {
                Id = c.Id,
                NoteId = c.NoteId,
                UserId = c.CollaboratorId,
                UserEmail = c.CollaboratorUser?.Email ?? string.Empty,
                Permission = (ModelLayer.Enums.PermissionLevel)c.Permission,
                CreatedAt = c.CreatedAt
            });
        }

        public async Task<CollaboratorResponseDto> AddAsync(AddCollaboratorDto dto, int ownerUserId)
        {
            var note = await _noteRepository.GetByIdAsync(dto.NoteId)
                ?? throw new NotFoundException("Note not found");

            if (note.UserId != ownerUserId)
                throw new UnauthorizedException("Only the note owner can add collaborators");

            if (dto.UserId == ownerUserId)
                throw new ValidationException("Cannot add yourself as a collaborator");

            // Check if collaborator user exists
            var collaboratorUser = await _userRepository.GetByIdAsync(dto.UserId)
                ?? throw new NotFoundException("Collaborator user not found");

            if (await _collaboratorRepository.ExistsAsync(dto.NoteId, dto.UserId))
                throw new ValidationException("This user is already a collaborator on this note");

            var collaborator = new Collaborator
            {
                NoteId = dto.NoteId,
                CollaboratorId = dto.UserId,
                Permission = (DataBaseLayer.Enums.PermissionLevel)dto.Permission,
                CreatedAt = DateTime.UtcNow
            };

            await _collaboratorRepository.AddAsync(collaborator);
            await _collaboratorRepository.SaveAsync();

            return new CollaboratorResponseDto
            {
                Id = collaborator.Id,
                NoteId = collaborator.NoteId,
                UserId = collaborator.CollaboratorId,
                UserEmail = collaboratorUser.Email,
                Permission = (ModelLayer.Enums.PermissionLevel)collaborator.Permission,
                CreatedAt = collaborator.CreatedAt
            };
        }

        public async Task<CollaboratorResponseDto> UpdatePermissionAsync(int collaboratorId, UpdatePermissionDto dto, int ownerUserId)
        {
            var collaborator = await _collaboratorRepository.GetByIdWithUserAsync(collaboratorId)
                ?? throw new NotFoundException("Collaborator not found");

            var note = await _noteRepository.GetByIdAsync(collaborator.NoteId)
                ?? throw new NotFoundException("Note not found");

            if (note.UserId != ownerUserId)
                throw new UnauthorizedException("Only the note owner can update permissions");

            collaborator.Permission = (DataBaseLayer.Enums.PermissionLevel)dto.Permission;
            collaborator.UpdatedAt = DateTime.UtcNow;

            await _collaboratorRepository.SaveAsync();

            return new CollaboratorResponseDto
            {
                Id = collaborator.Id,
                NoteId = collaborator.NoteId,
                UserId = collaborator.CollaboratorId,
                UserEmail = collaborator.CollaboratorUser?.Email ?? string.Empty,
                Permission = (ModelLayer.Enums.PermissionLevel)collaborator.Permission,
                CreatedAt = collaborator.CreatedAt
            };
        }

        public async Task RemoveAsync(int collaboratorId, int ownerUserId)
        {
            var collaborator = await _collaboratorRepository.GetByIdAsync(collaboratorId)
                ?? throw new NotFoundException("Collaborator not found");

            var note = await _noteRepository.GetByIdAsync(collaborator.NoteId)
                ?? throw new NotFoundException("Note not found");

            if (note.UserId != ownerUserId)
                throw new UnauthorizedException("Only the note owner can remove collaborators");

            await _collaboratorRepository.DeleteAsync(collaborator);
            await _collaboratorRepository.SaveAsync();
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\BusinessLayer\Services\LabelService.cs ==========
// ========================================
// FILE: BusinessLayer/Services/LabelService.cs (COMPLETE & FIXED)
// ========================================
using BusinessLayer.Exceptions;
using BusinessLayer.Interfaces.Services;
using BusinessLayer.Rules;  // ✅ ADD THIS LINE
using DataBaseLayer.Entities;
using DataBaseLayer.Interfaces;
using ModelLayer.DTOs.Labels;

namespace BusinessLayer.Services
{
    public class LabelService : ILabelService
    {
        private readonly ILabelRepository _labelRepository;

        public LabelService(ILabelRepository labelRepository)
        {
            _labelRepository = labelRepository;
        }

        public async Task<IEnumerable<LabelResponseDto>> GetByUserAsync(int userId)
        {
            var labels = await _labelRepository.GetByUserAsync(userId);
            return labels.Select(l => new LabelResponseDto
            {
                Id = l.Id,
                Name = l.Name,
                CreatedAt = l.CreatedAt
            });
        }

        public async Task<LabelResponseDto?> GetByIdAsync(int labelId, int userId)
        {
            var label = await _labelRepository.GetByIdAsync(labelId);

            if (label == null)
                return null;

            if (label.UserId != userId)
                throw new UnauthorizedException("Access denied to this label");

            return new LabelResponseDto
            {
                Id = label.Id,
                Name = label.Name,
                CreatedAt = label.CreatedAt
            };
        }

        public async Task<LabelResponseDto> CreateAsync(CreateLabelDto dto, int userId)
        {
            LabelRules.ValidateName(dto.Name);

            // Check for duplicate label name for this user
            if (await _labelRepository.ExistsForUserAsync(dto.Name, userId))
                throw new ValidationException("A label with this name already exists");

            var label = new Label
            {
                Name = dto.Name.Trim(),
                UserId = userId,
                CreatedAt = DateTime.UtcNow
            };

            await _labelRepository.AddAsync(label);
            await _labelRepository.SaveAsync();

            return new LabelResponseDto
            {
                Id = label.Id,
                Name = label.Name,
                CreatedAt = label.CreatedAt
            };
        }

        public async Task<LabelResponseDto> UpdateAsync(int labelId, UpdateLabelDto dto, int userId)
        {
            LabelRules.ValidateName(dto.Name);

            var label = await _labelRepository.GetByIdAsync(labelId)
                ?? throw new NotFoundException("Label not found");

            if (label.UserId != userId)
                throw new UnauthorizedException("Access denied to this label");

            // Check for duplicate name (excluding current label)
            if (await _labelRepository.ExistsForUserAsync(dto.Name, userId, labelId))
                throw new ValidationException("A label with this name already exists");

            label.Name = dto.Name.Trim();

            await _labelRepository.SaveAsync();

            return new LabelResponseDto
            {
                Id = label.Id,
                Name = label.Name,
                CreatedAt = label.CreatedAt
            };
        }

        public async Task DeleteAsync(int labelId, int userId)
        {
            var label = await _labelRepository.GetByIdAsync(labelId)
                ?? throw new NotFoundException("Label not found");

            if (label.UserId != userId)
                throw new UnauthorizedException("Access denied to this label");

            await _labelRepository.DeleteAsync(label);
            await _labelRepository.SaveAsync();
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\BusinessLayer\Services\NoteService.cs ==========
using BusinessLayer.Exceptions;
using BusinessLayer.Interfaces.Services;
using BusinessLayer.Rules;
using DataBaseLayer.Entities;
using DataBaseLayer.Interfaces;
using ModelLayer.DTOs.Notes;

namespace BusinessLayer.Services
{
    public class NoteService : INoteService
    {
        private readonly INoteRepository _noteRepository;
        private readonly ICollaboratorRepository _collaboratorRepository;

        public NoteService(INoteRepository noteRepository, ICollaboratorRepository collaboratorRepository)
        {
            _noteRepository = noteRepository;
            _collaboratorRepository = collaboratorRepository;
        }

        public async Task<IEnumerable<NoteResponseDto>> GetAllAsync(int userId)
        {
            var notes = await _noteRepository.GetByUserAsync(userId);
            return notes.Select(MapToDto);
        }

        public async Task<NoteResponseDto?> GetByIdAsync(int noteId, int userId)
        {
            var note = await _noteRepository.GetByIdAsync(noteId);

            if (note == null)
                return null;

            // Check if user is owner or collaborator
            if (note.UserId != userId && !await _collaboratorRepository.ExistsAsync(noteId, userId))
                throw new UnauthorizedException("Access denied to this note");

            return MapToDto(note);
        }

        public async Task<NoteResponseDto> CreateAsync(CreateNoteDto dto, int userId)
        {
            NoteRules.ValidateCreate(dto);

            var note = new Note
            {
                Title = dto.Title ?? "Untitled",
                Content = dto.Content ?? string.Empty,
                Color = dto.Color ?? "#FFFFFF",
                UserId = userId,
                IsPinned = false,
                IsArchived = false,
                IsDeleted = false,
                CreatedAt = DateTime.UtcNow
            };

            await _noteRepository.AddAsync(note);
            await _noteRepository.SaveAsync();

            return MapToDto(note);
        }

        public async Task<NoteResponseDto> UpdateAsync(int noteId, UpdateNoteDto dto, int userId)
        {
            var note = await _noteRepository.GetByIdAsync(noteId)
                ?? throw new NotFoundException("Note not found");

            // Check permission (owner or collaborator with edit permission)
            if (note.UserId != userId)
            {
                var collaborator = await _collaboratorRepository.GetByNoteAndUserAsync(noteId, userId);
                if (collaborator == null || collaborator.Permission != DataBaseLayer.Enums.PermissionLevel.Edit)
                    throw new UnauthorizedException("You don't have permission to edit this note");
            }

            // Update fields
            if (!string.IsNullOrWhiteSpace(dto.Title))
            {
                if (dto.Title.Length > 200)
                    throw new ValidationException("Title cannot exceed 200 characters");
                note.Title = dto.Title;
            }

            if (dto.Content != null)
            {
                if (dto.Content.Length > 10000)
                    throw new ValidationException("Content cannot exceed 10000 characters");
                note.Content = dto.Content;
            }

            note.UpdatedAt = DateTime.UtcNow;

            await _noteRepository.SaveAsync();

            return MapToDto(note);
        }

        public async Task DeleteAsync(int noteId, int userId)
        {
            var note = await _noteRepository.GetByIdAsync(noteId)
                ?? throw new NotFoundException("Note not found");

            if (note.UserId != userId)
                throw new UnauthorizedException("Only the owner can delete this note");

            // Soft delete
            note.IsDeleted = true;
            note.DeletedAt = DateTime.UtcNow;

            await _noteRepository.SaveAsync();
        }

        public async Task BulkDeleteAsync(BulkDeleteDto dto, int userId)
        {
            if (dto.NoteIds == null || !dto.NoteIds.Any())
                throw new ValidationException("At least one note ID is required");

            if (dto.NoteIds.Count() > 100)
                throw new ValidationException("Cannot delete more than 100 notes at once");

            var notes = await _noteRepository.GetByIdsAsync(dto.NoteIds);

            foreach (var note in notes)
            {
                if (note.UserId != userId)
                    continue; // Skip notes that don't belong to user

                note.IsDeleted = true;
                note.DeletedAt = DateTime.UtcNow;
            }

            await _noteRepository.SaveAsync();
        }

        public async Task<IEnumerable<NoteResponseDto>> SearchAsync(SearchNotesDto dto, int userId)
        {
            if (string.IsNullOrWhiteSpace(dto.Query))
                return new List<NoteResponseDto>();

            if (dto.Query.Length > 200)
                throw new ValidationException("Search query cannot exceed 200 characters");

            var notes = await _noteRepository.SearchAsync(dto.Query, userId);
            return notes.Select(MapToDto);
        }

        public async Task<NoteResponseDto> TogglePinAsync(int noteId, int userId)
        {
            var note = await _noteRepository.GetByIdAsync(noteId)
                ?? throw new NotFoundException("Note not found");

            if (note.UserId != userId)
                throw new UnauthorizedException("Only the owner can pin/unpin notes");

            note.IsPinned = !note.IsPinned;
            note.UpdatedAt = DateTime.UtcNow;

            await _noteRepository.SaveAsync();

            return MapToDto(note);
        }

        public async Task<NoteResponseDto> ToggleArchiveAsync(int noteId, int userId)
        {
            var note = await _noteRepository.GetByIdAsync(noteId)
                ?? throw new NotFoundException("Note not found");

            if (note.UserId != userId)
                throw new UnauthorizedException("Only the owner can archive/unarchive notes");

            note.IsArchived = !note.IsArchived;
            note.UpdatedAt = DateTime.UtcNow;

            await _noteRepository.SaveAsync();

            return MapToDto(note);
        }

        public async Task<NoteResponseDto> UpdateColorAsync(int noteId, UpdateNoteColorDto dto, int userId)
        {
            NoteRules.ValidateColor(dto.Color);

            var note = await _noteRepository.GetByIdAsync(noteId)
                ?? throw new NotFoundException("Note not found");

            if (note.UserId != userId)
                throw new UnauthorizedException("Only the owner can change note color");

            note.Color = dto.Color;
            note.UpdatedAt = DateTime.UtcNow;

            await _noteRepository.SaveAsync();

            return MapToDto(note);
        }

        private static NoteResponseDto MapToDto(Note note)
        {
            return new NoteResponseDto
            {
                Id = note.Id,
                Title = note.Title,
                Content = note.Content,
                Color = note.Color,
                IsPinned = note.IsPinned,
                IsArchived = note.IsArchived,
                CreatedAt = note.CreatedAt,
                UpdatedAt = note.UpdatedAt
            };
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Configurations\CollaboratorConfiguration.cs ==========
// ========================================
// FILE: DataBaseLayer/Configurations/CollaboratorConfiguration.cs (FIXED)
// ========================================
using DataBaseLayer.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DataBaseLayer.Configurations
{
    public class CollaboratorConfiguration : IEntityTypeConfiguration<Collaborator>
    {
        public void Configure(EntityTypeBuilder<Collaborator> builder)
        {
            builder.ToTable("Collaborators");
            builder.HasKey(x => x.Id);

            builder.Property(x => x.Permission)
                .IsRequired()
                .HasConversion<string>()
                .HasMaxLength(20);

            builder.Property(x => x.CreatedAt)
                .IsRequired()
                .HasDefaultValueSql("GETUTCDATE()");

            builder.HasIndex(x => new { x.NoteId, x.CollaboratorId })
                .IsUnique()
                .HasDatabaseName("IX_Collaborators_NoteId_CollaboratorId");

            builder.HasIndex(x => x.NoteId)
                .HasDatabaseName("IX_Collaborators_NoteId");

            builder.HasIndex(x => x.CollaboratorId)
                .HasDatabaseName("IX_Collaborators_CollaboratorId");

            // Relationships
            builder.HasOne(c => c.Note)
                .WithMany(n => n.Collaborators)
                .HasForeignKey(c => c.NoteId)
                .OnDelete(DeleteBehavior.Cascade); // ✅ Note deletion cascades

            builder.HasOne(c => c.CollaboratorUser)
                .WithMany(u => u.CollaboratedNotes)
                .HasForeignKey(c => c.CollaboratorId)
                .OnDelete(DeleteBehavior.Restrict); // ✅ User deletion restricted
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Configurations\LabelConfiguration.cs ==========
// ========================================
// FILE: DataBaseLayer/Configurations/LabelConfiguration.cs (FIXED)
// ========================================
using DataBaseLayer.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DataBaseLayer.Configurations
{
    public class LabelConfiguration : IEntityTypeConfiguration<Label>
    {
        public void Configure(EntityTypeBuilder<Label> builder)
        {
            builder.ToTable("Labels");
            builder.HasKey(x => x.Id);

            builder.Property(x => x.Name)
                .IsRequired()
                .HasMaxLength(50);

            builder.Property(x => x.CreatedAt)
                .IsRequired()
                .HasDefaultValueSql("GETUTCDATE()");

            builder.HasIndex(x => new { x.UserId, x.Name })
                .IsUnique()
                .HasDatabaseName("IX_Labels_UserId_Name");

            // Relationships
            builder.HasMany(l => l.NoteLabels)
                .WithOne(nl => nl.Label)
                .HasForeignKey(nl => nl.LabelId)
                .OnDelete(DeleteBehavior.Restrict); // ✅ Changed to Restrict to prevent cycles
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Configurations\NoteConfiguration.cs ==========
// ========================================
// FILE: DataBaseLayer/Configurations/NoteConfiguration.cs (FIXED)
// ========================================
using DataBaseLayer.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DataBaseLayer.Configurations
{
    public class NoteConfiguration : IEntityTypeConfiguration<Note>
    {
        public void Configure(EntityTypeBuilder<Note> builder)
        {
            builder.ToTable("Notes");
            builder.HasKey(x => x.Id);

            builder.Property(x => x.Title)
                .HasMaxLength(200);

            builder.Property(x => x.Content)
                .HasMaxLength(10000);

            builder.Property(x => x.Color)
                .HasMaxLength(7)
                .HasDefaultValue("#FFFFFF");

            builder.Property(x => x.IsPinned)
                .HasDefaultValue(false);

            builder.Property(x => x.IsArchived)
                .HasDefaultValue(false);

            builder.Property(x => x.IsDeleted)
                .HasDefaultValue(false);

            builder.Property(x => x.CreatedAt)
                .IsRequired()
                .HasDefaultValueSql("GETUTCDATE()");

            // Indexes
            builder.HasIndex(x => x.UserId)
                .HasDatabaseName("IX_Notes_UserId");

            builder.HasIndex(x => new { x.UserId, x.IsDeleted })
                .HasDatabaseName("IX_Notes_UserId_IsDeleted");

            builder.HasIndex(x => new { x.UserId, x.IsPinned })
                .HasDatabaseName("IX_Notes_UserId_IsPinned");

            // Relationships
            builder.HasMany(n => n.NoteLabels)
                .WithOne(nl => nl.Note)
                .HasForeignKey(nl => nl.NoteId)
                .OnDelete(DeleteBehavior.Cascade); // ✅ Note deletes NoteLabels

            builder.HasMany(n => n.Collaborators)
                .WithOne(c => c.Note)
                .HasForeignKey(c => c.NoteId)
                .OnDelete(DeleteBehavior.Cascade); // ✅ Note deletes Collaborators
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Configurations\NoteLabelConfiguration.cs ==========
// ========================================
// FILE: DataBaseLayer/Configurations/NoteLabelConfiguration.cs
// ========================================
using DataBaseLayer.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DataBaseLayer.Configurations
{
    public class NoteLabelConfiguration : IEntityTypeConfiguration<NoteLabel>
    {
        public void Configure(EntityTypeBuilder<NoteLabel> builder)
        {
            builder.ToTable("NoteLabels");

            // Composite Primary Key
            builder.HasKey(nl => new { nl.NoteId, nl.LabelId });

            // Properties
            builder.Property(nl => nl.CreatedAt)
                .IsRequired()
                .HasDefaultValueSql("GETUTCDATE()");

            // Relationships
            builder.HasOne(nl => nl.Note)
                .WithMany(n => n.NoteLabels)
                .HasForeignKey(nl => nl.NoteId)
                .OnDelete(DeleteBehavior.Cascade);

            builder.HasOne(nl => nl.Label)
                .WithMany(l => l.NoteLabels)
                .HasForeignKey(nl => nl.LabelId)
                .OnDelete(DeleteBehavior.Restrict); // ✅ Prevent cascade cycles

            // Indexes
            builder.HasIndex(nl => nl.NoteId)
                .HasDatabaseName("IX_NoteLabels_NoteId");

            builder.HasIndex(nl => nl.LabelId)
                .HasDatabaseName("IX_NoteLabels_LabelId");
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Configurations\UserConfiguration.cs ==========
// ========================================
// FILE: DataBaseLayer/Configurations/UserConfiguration.cs (ADD UpdatedAt)
// ========================================
using DataBaseLayer.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace DataBaseLayer.Configurations
{
    public class UserConfiguration : IEntityTypeConfiguration<User>
    {
        public void Configure(EntityTypeBuilder<User> builder)
        {
            builder.ToTable("Users");
            builder.HasKey(x => x.Id);

            // Properties
            builder.Property(x => x.Name)
                .IsRequired()
                .HasMaxLength(100);

            builder.Property(x => x.Email)
                .IsRequired()
                .HasMaxLength(255);

            builder.Property(x => x.PasswordHash)
                .IsRequired()
                .HasMaxLength(500);

            builder.Property(x => x.IsEmailVerified)
                .IsRequired()
                .HasDefaultValue(false);

            builder.Property(x => x.FailedLoginAttempts)
                .IsRequired()
                .HasDefaultValue(0);

            builder.Property(x => x.CreatedAt)
                .IsRequired()
                .HasDefaultValueSql("GETUTCDATE()");

            builder.Property(x => x.UpdatedAt) // ✅ ADDED
                .IsRequired(false);

            builder.Property(x => x.LastLoginAt)
                .IsRequired(false);

            builder.Property(x => x.LockoutEnd)
                .IsRequired(false);

            builder.Property(x => x.EmailVerificationToken)
                .HasMaxLength(100);

            builder.Property(x => x.EmailVerificationExpiry)
                .IsRequired(false);

            builder.Property(x => x.PasswordResetToken)
                .HasMaxLength(100);

            builder.Property(x => x.PasswordResetExpiry)
                .IsRequired(false);

            builder.Property(x => x.RefreshToken)
                .HasMaxLength(500);

            builder.Property(x => x.RefreshTokenExpiry)
                .IsRequired(false);

            // Indexes
            builder.HasIndex(x => x.Email)
                .IsUnique()
                .HasDatabaseName("IX_Users_Email");

            builder.HasIndex(x => x.RefreshToken)
                .HasDatabaseName("IX_Users_RefreshToken");

            builder.HasIndex(x => x.PasswordResetToken)
                .HasDatabaseName("IX_Users_PasswordResetToken");

            builder.HasIndex(x => x.EmailVerificationToken)
                .HasDatabaseName("IX_Users_EmailVerificationToken");

            // Relationships
            builder.HasMany(x => x.Notes)
                .WithOne(n => n.User)
                .HasForeignKey(n => n.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            builder.HasMany(x => x.Labels)
                .WithOne(l => l.User)
                .HasForeignKey(l => l.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            builder.HasMany(x => x.CollaboratedNotes)
                .WithOne(c => c.CollaboratorUser)
                .HasForeignKey(c => c.CollaboratorId)
                .OnDelete(DeleteBehavior.Restrict);
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Context\FundooAppDbContext.cs ==========
// ========================================
// FILE: DataBaseLayer/Context/FundooAppDbContext.cs (FIXED)
// ========================================
using DataBaseLayer.Entities;
using Microsoft.EntityFrameworkCore;

namespace DataBaseLayer.Context
{
    public class FundooAppDbContext : DbContext
    {
        public FundooAppDbContext(DbContextOptions<FundooAppDbContext> options)
            : base(options)
        {
        }

        // DbSets
        public DbSet<User> Users => Set<User>();
        public DbSet<Note> Notes => Set<Note>();
        public DbSet<Label> Labels => Set<Label>();
        public DbSet<NoteLabel> NoteLabels => Set<NoteLabel>();
        public DbSet<Collaborator> Collaborators => Set<Collaborator>();

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            // Apply all entity configurations from assembly
            modelBuilder.ApplyConfigurationsFromAssembly(typeof(FundooAppDbContext).Assembly);
        }

        public override Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
        {
            // Automatically set UpdatedAt for modified entities
            var entries = ChangeTracker.Entries()
                .Where(e => e.State == EntityState.Modified);

            foreach (var entry in entries)
            {
                if (entry.Entity is Note note)
                {
                    note.UpdatedAt = DateTime.UtcNow;
                }
                else if (entry.Entity is User user)
                {
                    user.UpdatedAt = DateTime.UtcNow; // ✅ Now works
                }
            }

            return base.SaveChangesAsync(cancellationToken);
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Entities\Collaborator.cs ==========
using DataBaseLayer.Enums;

namespace DataBaseLayer.Entities
{
    public class Collaborator
    {
        public int Id { get; set; }

        // Foreign Keys
        public int NoteId { get; set; }
        public int CollaboratorId { get; set; }

        // Permission
        public PermissionLevel Permission { get; set; }

        // Timestamps
        public DateTime CreatedAt { get; set; }
        public DateTime? UpdatedAt { get; set; }

        // Navigation Properties
        public Note Note { get; set; } = null!;
        public User CollaboratorUser { get; set; } = null!;
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Entities\Label.cs ==========
// ========================================
// FILE: DataBaseLayer/Entities/Label.cs (COMPLETE & FIXED)
// ========================================
namespace DataBaseLayer.Entities
{
    public class Label
    {
        public int Id { get; set; }
        public string Name { get; set; } = null!;
        public DateTime CreatedAt { get; set; }
        public int UserId { get; set; }

        // Navigation Properties
        public User User { get; set; } = null!;
        public ICollection<NoteLabel> NoteLabels { get; set; } = new HashSet<NoteLabel>(); // ✅ Only NoteLabels
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Entities\Note.cs ==========
// ========================================
// FILE: DataBaseLayer/Entities/Note.cs (COMPLETE & FIXED)
// ========================================
namespace DataBaseLayer.Entities
{
    public class Note
    {
        public int Id { get; set; }
        public string? Title { get; set; }
        public string? Content { get; set; }
        public string Color { get; set; } = "#FFFFFF";
        public bool IsPinned { get; set; }
        public bool IsArchived { get; set; }
        public bool IsDeleted { get; set; }
        public DateTime CreatedAt { get; set; }
        public DateTime? UpdatedAt { get; set; }
        public DateTime? DeletedAt { get; set; }
        public int UserId { get; set; }

        // Navigation Properties
        public User User { get; set; } = null!;
        public ICollection<NoteLabel> NoteLabels { get; set; } = new HashSet<NoteLabel>(); // ✅ Only NoteLabels
        public ICollection<Collaborator> Collaborators { get; set; } = new HashSet<Collaborator>();
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Entities\NoteLabel.cs ==========

namespace DataBaseLayer.Entities
{
    public class NoteLabel
    {
        public int NoteId { get; set; }
        public int LabelId { get; set; }
        public DateTime CreatedAt { get; set; }

        // Navigation Properties
        public Note Note { get; set; } = null!;
        public Label Label { get; set; } = null!;
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Entities\User.cs ==========
// ========================================
// FILE: DataBaseLayer/Entities/User.cs (COMPLETE & FIXED)
// ========================================
namespace DataBaseLayer.Entities
{
    public class User
    {
        public int Id { get; set; }
        public string Name { get; set; } = null!;
        public string Email { get; set; } = null!;
        public string PasswordHash { get; set; } = null!;
        public bool IsEmailVerified { get; set; }
        public string? EmailVerificationToken { get; set; }
        public DateTime? EmailVerificationExpiry { get; set; }
        public string? PasswordResetToken { get; set; }
        public DateTime? PasswordResetExpiry { get; set; }
        public string? RefreshToken { get; set; }
        public DateTime? RefreshTokenExpiry { get; set; }
        public int FailedLoginAttempts { get; set; }
        public DateTime? LockoutEnd { get; set; }
        public DateTime? LastLoginAt { get; set; }
        public DateTime CreatedAt { get; set; }
        public DateTime? UpdatedAt { get; set; } // ✅ ADDED

        // Navigation Properties
        public ICollection<Note> Notes { get; set; } = new HashSet<Note>();
        public ICollection<Label> Labels { get; set; } = new HashSet<Label>();
        public ICollection<Collaborator> CollaboratedNotes { get; set; } = new HashSet<Collaborator>();
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Enums\PermissionLevel.cs ==========
namespace DataBaseLayer.Enums
{
    public enum PermissionLevel
    {
        View = 0,
        Edit = 1
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Interfaces\ICollaboratorRepository.cs ==========
using DataBaseLayer.Entities;

namespace DataBaseLayer.Interfaces
{
    public interface ICollaboratorRepository
    {
        Task<Collaborator?> GetByIdAsync(int id);
        Task<Collaborator?> GetByIdWithUserAsync(int id);
        Task<Collaborator?> GetByNoteAndUserAsync(int noteId, int userId);
        Task<IEnumerable<Collaborator>> GetByNoteIdAsync(int noteId);
        Task<bool> ExistsAsync(int noteId, int collaboratorUserId);
        Task AddAsync(Collaborator collaborator);
        Task DeleteAsync(Collaborator collaborator);
        Task SaveAsync();
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Interfaces\ILabelRepository.cs ==========
using DataBaseLayer.Entities;

namespace DataBaseLayer.Interfaces
{
    public interface ILabelRepository
    {
        Task<Label?> GetByIdAsync(int id);
        Task<IEnumerable<Label>> GetByUserAsync(int userId);
        Task<bool> ExistsForUserAsync(string name, int userId, int? excludeLabelId = null);
        Task AddAsync(Label label);
        Task DeleteAsync(Label label);
        Task SaveAsync();
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Interfaces\INoteRepository.cs ==========
using DataBaseLayer.Entities;

namespace DataBaseLayer.Interfaces
{
    public interface INoteRepository
    {
        Task<Note?> GetByIdAsync(int id);
        Task<IEnumerable<Note>> GetByUserAsync(int userId);
        Task<IEnumerable<Note>> GetByIdsAsync(IEnumerable<int> ids);
        Task<IEnumerable<Note>> SearchAsync(string query, int userId);
        Task AddAsync(Note note);
        Task DeleteAsync(Note note);
        Task SaveAsync();
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Interfaces\IUserRepository.cs ==========
using DataBaseLayer.Entities;

namespace DataBaseLayer.Interfaces
{
    public interface IUserRepository
    {
        Task<User?> GetByIdAsync(int id);
        Task<User?> GetByEmailAsync(string email);
        Task<User?> GetByRefreshTokenAsync(string refreshToken);
        Task<User?> GetByResetTokenAsync(string resetToken);
        Task<User?> GetByEmailVerificationTokenAsync(string token);
        Task AddAsync(User user);
        Task DeleteAsync(User user);
        Task SaveAsync();
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Repositories\CollaboratorRepository.cs ==========
using DataBaseLayer.Context;
using DataBaseLayer.Entities;
using DataBaseLayer.Interfaces;
using Microsoft.EntityFrameworkCore;

namespace DataBaseLayer.Repositories
{
    public class CollaboratorRepository : ICollaboratorRepository
    {
        private readonly FundooAppDbContext _context;

        public CollaboratorRepository(FundooAppDbContext context)
        {
            _context = context;
        }

        public async Task<Collaborator?> GetByIdAsync(int id)
        {
            return await _context.Collaborators
                .FirstOrDefaultAsync(c => c.Id == id);
        }

        public async Task<Collaborator?> GetByIdWithUserAsync(int id)
        {
            return await _context.Collaborators
                .Include(c => c.CollaboratorUser)
                .FirstOrDefaultAsync(c => c.Id == id);
        }

        public async Task<Collaborator?> GetByNoteAndUserAsync(int noteId, int userId)
        {
            return await _context.Collaborators
                .FirstOrDefaultAsync(c => c.NoteId == noteId && c.CollaboratorId == userId);
        }

        public async Task<IEnumerable<Collaborator>> GetByNoteIdAsync(int noteId)
        {
            return await _context.Collaborators
                .Include(c => c.CollaboratorUser)
                .Where(c => c.NoteId == noteId)
                .OrderBy(c => c.CreatedAt)
                .ToListAsync();
        }

        public async Task<bool> ExistsAsync(int noteId, int collaboratorUserId)
        {
            return await _context.Collaborators
                .AnyAsync(c => c.NoteId == noteId && c.CollaboratorId == collaboratorUserId);
        }

        public async Task AddAsync(Collaborator collaborator)
        {
            await _context.Collaborators.AddAsync(collaborator);
        }

        public Task DeleteAsync(Collaborator collaborator)
        {
            _context.Collaborators.Remove(collaborator);
            return Task.CompletedTask;
        }

        public async Task SaveAsync()
        {
            await _context.SaveChangesAsync();
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Repositories\LabelRepository.cs ==========
using DataBaseLayer.Context;
using DataBaseLayer.Entities;
using DataBaseLayer.Interfaces;
using Microsoft.EntityFrameworkCore;

namespace DataBaseLayer.Repositories
{
    public class LabelRepository : ILabelRepository
    {
        private readonly FundooAppDbContext _context;

        public LabelRepository(FundooAppDbContext context)
        {
            _context = context;
        }

        public async Task<Label?> GetByIdAsync(int id)
        {
            return await _context.Labels
                .Include(l => l.Notes)
                .FirstOrDefaultAsync(l => l.Id == id);
        }

        public async Task<IEnumerable<Label>> GetByUserAsync(int userId)
        {
            return await _context.Labels
                .Where(l => l.UserId == userId)
                .OrderBy(l => l.Name)
                .ToListAsync();
        }

        public async Task<bool> ExistsForUserAsync(string name, int userId, int? excludeLabelId = null)
        {
            var query = _context.Labels
                .Where(l => l.UserId == userId && l.Name.ToLower() == name.ToLower());

            if (excludeLabelId.HasValue)
            {
                query = query.Where(l => l.Id != excludeLabelId.Value);
            }

            return await query.AnyAsync();
        }

        public async Task AddAsync(Label label)
        {
            await _context.Labels.AddAsync(label);
        }

        public Task DeleteAsync(Label label)
        {
            _context.Labels.Remove(label);
            return Task.CompletedTask;
        }

        public async Task SaveAsync()
        {
            await _context.SaveChangesAsync();
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Repositories\NoteRepository.cs ==========
// ========================================
// FILE: DataBaseLayer/Repositories/NoteRepository.cs (COMPLETE & FIXED)
// ========================================
using DataBaseLayer.Context;
using DataBaseLayer.Entities;
using DataBaseLayer.Interfaces;
using Microsoft.EntityFrameworkCore;

namespace DataBaseLayer.Repositories
{
    public class NoteRepository : INoteRepository
    {
        private readonly FundooAppDbContext _context;

        public NoteRepository(FundooAppDbContext context)
        {
            _context = context;
        }

        public async Task<Note?> GetByIdAsync(int id)
        {
            return await _context.Notes
                .Include(n => n.NoteLabels)       // ✅ Changed from Labels
                    .ThenInclude(nl => nl.Label)  // ✅ Added ThenInclude
                .Include(n => n.Collaborators)
                    .ThenInclude(c => c.CollaboratorUser)
                .FirstOrDefaultAsync(n => n.Id == id);
        }

        public async Task<IEnumerable<Note>> GetByUserIdAsync(int userId)
        {
            return await _context.Notes
                .Include(n => n.NoteLabels)       // ✅ Changed from Labels
                    .ThenInclude(nl => nl.Label)  // ✅ Added ThenInclude
                .Where(n => n.UserId == userId && !n.IsDeleted)
                .OrderByDescending(n => n.IsPinned)
                .ThenByDescending(n => n.CreatedAt)
                .ToListAsync();
        }

        public async Task<IEnumerable<Note>> GetArchivedByUserIdAsync(int userId)
        {
            return await _context.Notes
                .Include(n => n.NoteLabels)
                    .ThenInclude(nl => nl.Label)
                .Where(n => n.UserId == userId && n.IsArchived && !n.IsDeleted)
                .OrderByDescending(n => n.CreatedAt)
                .ToListAsync();
        }

        public async Task<IEnumerable<Note>> GetDeletedByUserIdAsync(int userId)
        {
            return await _context.Notes
                .Include(n => n.NoteLabels)
                    .ThenInclude(nl => nl.Label)
                .Where(n => n.UserId == userId && n.IsDeleted)
                .OrderByDescending(n => n.DeletedAt)
                .ToListAsync();
        }

        public async Task<IEnumerable<Note>> SearchAsync(string query, int userId)
        {
            return await _context.Notes
                .Include(n => n.NoteLabels)
                    .ThenInclude(nl => nl.Label)
                .Where(n => n.UserId == userId && !n.IsDeleted &&
                    (n.Title!.Contains(query) || n.Content!.Contains(query)))
                .OrderByDescending(n => n.UpdatedAt)
                .ToListAsync();
        }

        public async Task<IEnumerable<Note>> GetByLabelIdAsync(int labelId, int userId)
        {
            return await _context.Notes
                .Include(n => n.NoteLabels)
                    .ThenInclude(nl => nl.Label)
                .Where(n => n.UserId == userId &&
                    !n.IsDeleted &&
                    n.NoteLabels.Any(nl => nl.LabelId == labelId)) // ✅ Changed
                .OrderByDescending(n => n.IsPinned)
                .ThenByDescending(n => n.CreatedAt)
                .ToListAsync();
        }

        public async Task<IEnumerable<Note>> GetByIdsAsync(IEnumerable<int> noteIds)
        {
            return await _context.Notes
                .Where(n => noteIds.Contains(n.Id))
                .ToListAsync();
        }

        public async Task<IEnumerable<Note>> GetCollaboratedNotesAsync(int userId)
        {
            return await _context.Notes
                .Include(n => n.NoteLabels)
                    .ThenInclude(nl => nl.Label)
                .Include(n => n.Collaborators)
                    .ThenInclude(c => c.CollaboratorUser)
                .Where(n => n.Collaborators.Any(c => c.CollaboratorId == userId) && !n.IsDeleted)
                .OrderByDescending(n => n.UpdatedAt)
                .ToListAsync();
        }

        public async Task AddAsync(Note note)
        {
            await _context.Notes.AddAsync(note);
        }

        public Task DeleteAsync(Note note)
        {
            _context.Notes.Remove(note);
            return Task.CompletedTask;
        }

        public async Task SaveAsync()
        {
            await _context.SaveChangesAsync();
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\DataBaseLayer\Repositories\UserRepository.cs ==========

using DataBaseLayer.Context;
using DataBaseLayer.Entities;
using DataBaseLayer.Interfaces;
using Microsoft.EntityFrameworkCore;

namespace DataBaseLayer.Repositories
{
    public class UserRepository : IUserRepository
    {
        private readonly FundooAppDbContext _context;

        public UserRepository(FundooAppDbContext context)
        {
            _context = context;
        }

        // Get user by ID (read-only)
        public async Task<User?> GetByIdAsync(int id)
        {
            return await _context.Users
                .AsNoTracking()
                .FirstOrDefaultAsync(x => x.Id == id);
        }

        // Get user by email
        public async Task<User?> GetByEmailAsync(string email)
        {
            return await _context.Users
                .FirstOrDefaultAsync(x => x.Email == email);
        }

        // Get user by refresh token
        public async Task<User?> GetByRefreshTokenAsync(string refreshToken)
        {
            return await _context.Users
                .FirstOrDefaultAsync(x => x.RefreshToken == refreshToken);
        }

        // Get user by password reset token
        public async Task<User?> GetByResetTokenAsync(string resetToken)
        {
            return await _context.Users
                .FirstOrDefaultAsync(x => x.PasswordResetToken == resetToken);
        }

        // Get user by email verification token
        public async Task<User?> GetByEmailVerificationTokenAsync(string token)
        {
            return await _context.Users
                .FirstOrDefaultAsync(x => x.EmailVerificationToken == token);
        }

        // Add new user
        public async Task AddAsync(User user)
        {
            await _context.Users.AddAsync(user);
        }

        // Delete user
        public Task DeleteAsync(User user)
        {
            _context.Users.Remove(user);
            return Task.CompletedTask;
        }

        // Save changes to database
        public async Task SaveAsync()
        {
            await _context.SaveChangesAsync();
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\FundooNotes\appsettings.Development.json ==========
{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft.AspNetCore": "Information",
      "Microsoft.EntityFrameworkCore": "Information",
      "Microsoft.EntityFrameworkCore.Database.Command": "Information",
      "System": "Information"
    }
  },

  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost\\SQLEXPRESS;Database=FundooNotesDb_Dev;Trusted_Connection=True;TrustServerCertificate=True;MultipleActiveResultSets=true"
  },

  "Jwt": {
    "Key": "684ca104bf8367f3c697f4c4202b81e6f87bb6694d8a278516f380e6684ca104",
    "Issuer": "FundooNotes-Dev",
    "Audience": "FundooUsers-Dev",
    "AccessTokenExpiryMinutes": 1440,
    "RefreshTokenExpiryDays": 30
  },

  "Smtp": {
    "Host": "smtp.gmail.com",
    "Port": 587,
    "EnableSsl": true,
    "UserName": "srikesh2017@gmail.com",
    "Password": "rrrbuuosifpxksdi",
    "FromName": "Fundoo Notes [DEV]",
    "FromEmail": "srikesh2017@gmail.com"
  },

  "AppSettings": {
    "ApplicationName": "Fundoo Notes [Development]",
    "ApplicationUrl": "https://localhost:7001",
    "MaxLoginAttempts": 10,
    "AccountLockoutMinutes": 5,
    "OtpExpiryMinutes": 30,
    "PasswordResetExpiryMinutes": 60,
    "MaxNotesPerUser": 100000,
    "MaxLabelsPerUser": 1000,
    "MaxCollaboratorsPerNote": 100
  },

  "Cors": {
    "AllowedOrigins": [
      "http://localhost:3000",
      "http://localhost:3001",
      "http://localhost:4200",
      "http://localhost:5173",
      "https://localhost:3000",
      "https://localhost:3001",
      "https://localhost:4200",
      "https://localhost:5173"
    ]
  },

  "Security": {
    "RequireHttpsMetadata": false,
    "SaveToken": true,
    "ValidateIssuer": false,
    "ValidateAudience": false,
    "ValidateLifetime": true,
    "ValidateIssuerSigningKey": true,
    "ClockSkew": 60
  }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\FundooNotes\appsettings.json ==========
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning",
      "Microsoft.EntityFrameworkCore.Database.Command": "Warning"
    }
  },

  "AllowedHosts": "*",

  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost\\SQLEXPRESS;Database=FundooNotesDb;Trusted_Connection=True;TrustServerCertificate=True;MultipleActiveResultSets=true"
  },

  "Jwt": {
    "Key": "684ca104bf8367f3c697f4c4202b81e6f87bb6694d8a278516f380e6684ca104",
    "Issuer": "FundooNotes",
    "Audience": "FundooUsers",
    "AccessTokenExpiryMinutes": 60,
    "RefreshTokenExpiryDays": 7
  },

  "Smtp": {
    "Host": "smtp.gmail.com",
    "Port": 587,
    "EnableSsl": true,
    "UserName": "srikesh2017@gmail.com",
    "Password": "rrrbuuosifpxksdi",
    "FromName": "Fundoo Notes",
    "FromEmail": "srikesh2017@gmail.com"
  },

  "AppSettings": {
    "ApplicationName": "Fundoo Notes",
    "ApplicationUrl": "https://localhost:7001",
    "MaxLoginAttempts": 5,
    "AccountLockoutMinutes": 15,
    "OtpExpiryMinutes": 10,
    "PasswordResetExpiryMinutes": 15,
    "MaxNotesPerUser": 10000,
    "MaxLabelsPerUser": 100,
    "MaxCollaboratorsPerNote": 50
  },

  "Cors": {
    "AllowedOrigins": [
      "http://localhost:3000",
      "http://localhost:4200",
      "https://localhost:3000",
      "https://localhost:4200"
    ]
  },

  "Security": {
    "RequireHttpsMetadata": true,
    "SaveToken": true,
    "ValidateIssuer": true,
    "ValidateAudience": true,
    "ValidateLifetime": true,
    "ValidateIssuerSigningKey": true,
    "ClockSkew": 5
  }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\FundooNotes\launchSettings.json ==========
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "https://localhost:7014;http://localhost:5233",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "http://localhost:5233",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "launchUrl": "swagger",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  },
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:27415",
      "sslPort": 44350
    }
  }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\FundooNotes\Program.cs ==========
// ========================================
// FILE: FundooNotes/Program.cs (ADD CONFIGURATION BINDING)
// ========================================
using BusinessLayer.Interfaces.Services;
using BusinessLayer.Services;
using DataBaseLayer.Context;
using DataBaseLayer.Interfaces;
using DataBaseLayer.Repositories;
using FundooNotes.Middleware;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.Tokens;
using Microsoft.OpenApi.Models;
using ModelLayer.Configuration;
using System.Text;

var builder = WebApplication.CreateBuilder(args);

// Bind Configuration Settings
builder.Services.Configure<JwtSettings>(builder.Configuration.GetSection("Jwt"));
builder.Services.Configure<SmtpSettings>(builder.Configuration.GetSection("Smtp"));
builder.Services.Configure<AppSettings>(builder.Configuration.GetSection("AppSettings"));
builder.Services.Configure<CorsSettings>(builder.Configuration.GetSection("Cors"));
builder.Services.Configure<SecuritySettings>(builder.Configuration.GetSection("Security"));

// Database Context
builder.Services.AddDbContext<FundooAppDbContext>(options =>
    options.UseSqlServer(
        builder.Configuration.GetConnectionString("DefaultConnection"),
        sqlOptions => sqlOptions.EnableRetryOnFailure(
            maxRetryCount: 3,
            maxRetryDelay: TimeSpan.FromSeconds(10),
            errorNumbersToAdd: null
        )
    )
);

// CORS Configuration
var corsSettings = builder.Configuration.GetSection("Cors").Get<CorsSettings>();
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowFrontend", policy =>
    {
        policy.WithOrigins(corsSettings?.AllowedOrigins ?? new[] { "http://localhost:3000" })
              .AllowAnyMethod()
              .AllowAnyHeader()
              .AllowCredentials();
    });
});

// JWT Authentication
var jwtSettings = builder.Configuration.GetSection("Jwt").Get<JwtSettings>();
var key = Encoding.UTF8.GetBytes(jwtSettings?.Key ?? throw new InvalidOperationException("JWT Key not configured"));

builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.RequireHttpsMetadata = false;
    options.SaveToken = true;
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuerSigningKey = true,
        IssuerSigningKey = new SymmetricSecurityKey(key),
        ValidateIssuer = true,
        ValidIssuer = jwtSettings.Issuer,
        ValidateAudience = true,
        ValidAudience = jwtSettings.Audience,
        ValidateLifetime = true,
        ClockSkew = TimeSpan.FromMinutes(5)
    };
});

// Repository Registration
builder.Services.AddScoped<IUserRepository, UserRepository>();
builder.Services.AddScoped<INoteRepository, NoteRepository>();
builder.Services.AddScoped<ILabelRepository, LabelRepository>();
builder.Services.AddScoped<ICollaboratorRepository, CollaboratorRepository>();

// Service Registration
builder.Services.AddScoped<IAuthService, AuthService>();
builder.Services.AddScoped<INoteService, NoteService>();
builder.Services.AddScoped<ILabelService, LabelService>();
builder.Services.AddScoped<ICollaboratorService, CollaboratorService>();

// Controllers
builder.Services.AddControllers();

// Swagger
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo
    {
        Title = "Fundoo Notes API",
        Version = "v1",
        Description = "RESTful API for Fundoo Notes Application",
        Contact = new OpenApiContact
        {
            Name = "Kotipalli Srikesh",
            Email = "srikesh2017@gmail.com"
        }
    });

    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        Description = "JWT Authorization header using Bearer scheme. Enter 'Bearer' [space] and then your token",
        Name = "Authorization",
        In = ParameterLocation.Header,
        Type = SecuritySchemeType.ApiKey,
        Scheme = "Bearer"
    });

    c.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            Array.Empty<string>()
        }
    });
});

var app = builder.Build();

// Configure Pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI(c =>
    {
        c.SwaggerEndpoint("/swagger/v1/swagger.json", "Fundoo Notes API v1");
        c.RoutePrefix = string.Empty;
    });
}

app.UseMiddleware<GlobalExceptionMiddleware>();
app.UseHttpsRedirection();
app.UseCors("AllowFrontend");
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();

app.Run();

public partial class Program { }

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\FundooNotes\Controllers\AuthController.cs ==========
using BusinessLayer.Interfaces.Services;
using FundooNotes.Helpers;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using ModelLayer.DTOs.Auth;
using ModelLayer.Responses;
using System.Security.Claims;

namespace FundooNotes.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class AuthController : ControllerBase
    {
        private readonly IAuthService _authService;
        private readonly JwtTokenGenerator _jwtTokenGenerator;
        private readonly OtpEmailSender _emailSender;
        private readonly ILogger<AuthController> _logger;

        public AuthController(
            IAuthService authService,
            JwtTokenGenerator jwtTokenGenerator,
            OtpEmailSender emailSender,
            ILogger<AuthController> logger)
        {
            _authService = authService;
            _jwtTokenGenerator = jwtTokenGenerator;
            _emailSender = emailSender;
            _logger = logger;
        }

        /// Register a new user

        [HttpPost("register")]
        [ProducesResponseType(typeof(ApiResponse<string>), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status400BadRequest)]
        public async Task<IActionResult> Register([FromBody] RegisterRequestDto dto)
        {
            _logger.LogInformation("Registration attempt for email: {Email}", dto.Email);

            var otp = await _authService.RegisterAsync(dto);

            // Send OTP via email
            await _emailSender.SendOtpEmailAsync(dto.Email, dto.Name, otp);

            _logger.LogInformation("User registered successfully: {Email}", dto.Email);

            return Ok(ApiResponse<string>.SuccessResponse(
                "Registration successful. Please check your email for OTP verification.",
                "OTP sent to email"));
        }


        /// Verify email with OTP

        [HttpPost("verify-email")]
        [ProducesResponseType(typeof(ApiResponse), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status400BadRequest)]
        public async Task<IActionResult> VerifyEmail([FromBody] VerifyOtpRequestDto dto)
        {
            _logger.LogInformation("Email verification attempt for: {Email}", dto.Email);

            await _authService.VerifyOtpAsync(dto.Email, dto.Otp);

            _logger.LogInformation("Email verified successfully: {Email}", dto.Email);

            return Ok(ApiResponse.SuccessResponse("Email verified successfully. You can now login."));
        }


        /// Login with email and password

        [HttpPost("login")]
        [ProducesResponseType(typeof(ApiResponse<AuthResponseDto>), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status401Unauthorized)]
        public async Task<IActionResult> Login([FromBody] LoginRequestDto dto)
        {
            _logger.LogInformation("Login attempt for email: {Email}", dto.Email);

            var authResponse = await _authService.LoginAsync(dto);

            // Generate JWT token
            var accessToken = _jwtTokenGenerator.GenerateToken(authResponse.UserId, authResponse.Email);
            authResponse.AccessToken = accessToken;

            _logger.LogInformation("User logged in successfully: {Email}", dto.Email);

            return Ok(ApiResponse<AuthResponseDto>.SuccessResponse(authResponse, "Login successful"));
        }


        /// Refresh access token using refresh token

        [HttpPost("refresh-token")]
        [ProducesResponseType(typeof(ApiResponse<AuthResponseDto>), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status401Unauthorized)]
        public async Task<IActionResult> RefreshToken([FromBody] RefreshTokenDto dto)
        {
            _logger.LogInformation("Refresh token attempt");

            var authResponse = await _authService.RefreshTokenAsync(dto.RefreshToken);


            var accessToken = _jwtTokenGenerator.GenerateToken(authResponse.UserId, authResponse.Email);
            authResponse.AccessToken = accessToken;

            _logger.LogInformation("Token refreshed successfully for user: {UserId}", authResponse.UserId);

            return Ok(ApiResponse<AuthResponseDto>.SuccessResponse(authResponse, "Token refreshed successfully"));
        }


        /// Request password reset

        [HttpPost("forgot-password")]
        [ProducesResponseType(typeof(ApiResponse), StatusCodes.Status200OK)]
        public async Task<IActionResult> ForgotPassword([FromBody] ForgotPasswordDto dto)
        {
            _logger.LogInformation("Password reset requested for email: {Email}", dto.Email);

            await _authService.ForgotPasswordAsync(dto.Email);

            return Ok(ApiResponse.SuccessResponse(
                "If the email exists, a password reset link has been sent."));
        }


        /// Reset password with token

        [HttpPost("reset-password")]
        [ProducesResponseType(typeof(ApiResponse), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status400BadRequest)]
        public async Task<IActionResult> ResetPassword([FromBody] ResetPasswordDto dto)
        {
            _logger.LogInformation("Password reset attempt with token");

            await _authService.ResetPasswordAsync(dto);

            _logger.LogInformation("Password reset successful");

            return Ok(ApiResponse.SuccessResponse("Password reset successful. You can now login with your new password."));
        }


        /// Logout user

        [Authorize]
        [HttpPost("logout")]
        [ProducesResponseType(typeof(ApiResponse), StatusCodes.Status200OK)]
        public async Task<IActionResult> Logout()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;

            if (string.IsNullOrEmpty(userIdClaim) || !int.TryParse(userIdClaim, out int userId))
            {
                return Unauthorized(new ErrorResponse("Invalid user token", "UNAUTHORIZED"));
            }

            _logger.LogInformation("Logout attempt for user: {UserId}", userId);

            await _authService.LogoutAsync(userId);

            _logger.LogInformation("User logged out successfully: {UserId}", userId);

            return Ok(ApiResponse.SuccessResponse("Logged out successfully"));
        }



        /// Get current user info
        [Authorize]
        [HttpGet("me")]
        [ProducesResponseType(typeof(ApiResponse<object>), StatusCodes.Status200OK)]
        public IActionResult GetCurrentUser()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            var emailClaim = User.FindFirst(ClaimTypes.Email)?.Value;

            var userInfo = new
            {
                UserId = userIdClaim,
                Email = emailClaim
            };

            return Ok(ApiResponse<object>.SuccessResponse(userInfo, "User info retrieved"));
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\FundooNotes\Controllers\CollaboratorsController.cs ==========
using BusinessLayer.Interfaces.Services;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using ModelLayer.DTOs.Collaborators;
using ModelLayer.Responses;
using System.Security.Claims;

namespace FundooNotes.Controllers
{
    [Authorize]
    [ApiController]
    [Route("api/[controller]")]
    public class CollaboratorsController : ControllerBase
    {
        private readonly ICollaboratorService _collaboratorService;
        private readonly ILogger<CollaboratorsController> _logger;

        public CollaboratorsController(
            ICollaboratorService collaboratorService,
            ILogger<CollaboratorsController> logger)
        {
            _collaboratorService = collaboratorService;
            _logger = logger;
        }

        private int GetUserId()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            return int.Parse(userIdClaim!);
        }

        
        /// Get all collaborators for a note
        
        [HttpGet("note/{noteId}")]
        [ProducesResponseType(typeof(ApiResponse<IEnumerable<CollaboratorResponseDto>>), StatusCodes.Status200OK)]
        public async Task<IActionResult> GetByNoteId(int noteId)
        {
            var userId = GetUserId();
            _logger.LogInformation("Fetching collaborators for note {NoteId}", noteId);

            var collaborators = await _collaboratorService.GetByNoteIdAsync(noteId, userId);

            return Ok(ApiResponse<IEnumerable<CollaboratorResponseDto>>.SuccessResponse(
                collaborators, $"Retrieved {collaborators.Count()} collaborators"));
        }


        /// Add collaborator to note
        
        [HttpPost]
        [ProducesResponseType(typeof(ApiResponse<CollaboratorResponseDto>), StatusCodes.Status201Created)]
        [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status400BadRequest)]
        public async Task<IActionResult> Add([FromBody] AddCollaboratorDto dto)
        {
            var userId = GetUserId();
            _logger.LogInformation("Adding collaborator to note {NoteId}", dto.NoteId);

            var collaborator = await _collaboratorService.AddAsync(dto, userId);

            _logger.LogInformation("Collaborator added: {CollaboratorId}", collaborator.Id);

            return CreatedAtAction(
                nameof(GetByNoteId),
                new { noteId = dto.NoteId },
                ApiResponse<CollaboratorResponseDto>.SuccessResponse(
                    collaborator, "Collaborator added successfully"));
        }


        /// Update collaborator permission

        [HttpPatch("{id}/permission")]
        [ProducesResponseType(typeof(ApiResponse<CollaboratorResponseDto>), StatusCodes.Status200OK)]
        public async Task<IActionResult> UpdatePermission(int id, [FromBody] UpdatePermissionDto dto)
        {
            var userId = GetUserId();
            _logger.LogInformation("Updating permission for collaborator {CollaboratorId}", id);

            var collaborator = await _collaboratorService.UpdatePermissionAsync(id, dto, userId);

            return Ok(ApiResponse<CollaboratorResponseDto>.SuccessResponse(
                collaborator, "Permission updated successfully"));
        }


        /// Remove collaborator

        [HttpDelete("{id}")]
        [ProducesResponseType(typeof(ApiResponse), StatusCodes.Status200OK)]
        public async Task<IActionResult> Remove(int id)
        {
            var userId = GetUserId();
            _logger.LogInformation("Removing collaborator {CollaboratorId}", id);

            await _collaboratorService.RemoveAsync(id, userId);

            return Ok(ApiResponse.SuccessResponse("Collaborator removed successfully"));
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\FundooNotes\Controllers\LabelsController.cs ==========
using BusinessLayer.Interfaces.Services;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using ModelLayer.DTOs.Labels;
using ModelLayer.Responses;
using System.Security.Claims;

namespace FundooNotes.Controllers
{
    [Authorize]
    [ApiController]
    [Route("api/[controller]")]
    public class LabelsController : ControllerBase
    {
        private readonly ILabelService _labelService;
        private readonly ILogger<LabelsController> _logger;

        public LabelsController(ILabelService labelService, ILogger<LabelsController> logger)
        {
            _labelService = labelService;
            _logger = logger;
        }

        private int GetUserId()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            return int.Parse(userIdClaim!);
        }


        /// Get all labels for current user

        [HttpGet]
        [ProducesResponseType(typeof(ApiResponse<IEnumerable<LabelResponseDto>>), StatusCodes.Status200OK)]
        public async Task<IActionResult> GetAll()
        {
            var userId = GetUserId();
            _logger.LogInformation("Fetching all labels for user: {UserId}", userId);

            var labels = await _labelService.GetByUserAsync(userId);

            return Ok(ApiResponse<IEnumerable<LabelResponseDto>>.SuccessResponse(
                labels, $"Retrieved {labels.Count()} labels"));
        }


        /// Get label by ID

        [HttpGet("{id}")]
        [ProducesResponseType(typeof(ApiResponse<LabelResponseDto>), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status404NotFound)]
        public async Task<IActionResult> GetById(int id)
        {
            var userId = GetUserId();
            _logger.LogInformation("Fetching label {LabelId} for user: {UserId}", id, userId);

            var label = await _labelService.GetByIdAsync(id, userId);

            if (label == null)
            {
                return NotFound(new ErrorResponse("Label not found"));
            }

            return Ok(ApiResponse<LabelResponseDto>.SuccessResponse(label, "Label retrieved"));
        }


        /// Create new label

        [HttpPost]
        [ProducesResponseType(typeof(ApiResponse<LabelResponseDto>), StatusCodes.Status201Created)]
        [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status400BadRequest)]
        public async Task<IActionResult> Create([FromBody] CreateLabelDto dto)
        {
            var userId = GetUserId();
            _logger.LogInformation("Creating label for user: {UserId}", userId);

            var label = await _labelService.CreateAsync(dto, userId);

            _logger.LogInformation("Label created: {LabelId}", label.Id);

            return CreatedAtAction(
                nameof(GetById),
                new { id = label.Id },
                ApiResponse<LabelResponseDto>.SuccessResponse(label, "Label created successfully"));
        }


        /// Update label

        [HttpPut("{id}")]
        [ProducesResponseType(typeof(ApiResponse<LabelResponseDto>), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status404NotFound)]
        public async Task<IActionResult> Update(int id, [FromBody] UpdateLabelDto dto)
        {
            var userId = GetUserId();
            _logger.LogInformation("Updating label {LabelId} for user: {UserId}", id, userId);

            var label = await _labelService.UpdateAsync(id, dto, userId);

            _logger.LogInformation("Label updated: {LabelId}", id);

            return Ok(ApiResponse<LabelResponseDto>.SuccessResponse(label, "Label updated successfully"));
        }


        /// Delete label

        [HttpDelete("{id}")]
        [ProducesResponseType(typeof(ApiResponse), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status404NotFound)]
        public async Task<IActionResult> Delete(int id)
        {
            var userId = GetUserId();
            _logger.LogInformation("Deleting label {LabelId} for user: {UserId}", id, userId);

            await _labelService.DeleteAsync(id, userId);

            _logger.LogInformation("Label deleted: {LabelId}", id);

            return Ok(ApiResponse.SuccessResponse("Label deleted successfully"));
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\FundooNotes\Controllers\NotesController.cs ==========
using BusinessLayer.Interfaces.Services;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using ModelLayer.DTOs.Notes;
using ModelLayer.Responses;
using System.Security.Claims;

namespace FundooNotes.Controllers
{
    [Authorize]
    [ApiController]
    [Route("api/[controller]")]
    public class NotesController : ControllerBase
    {
        private readonly INoteService _noteService;
        private readonly ILogger<NotesController> _logger;

        public NotesController(INoteService noteService, ILogger<NotesController> logger)
        {
            _noteService = noteService;
            _logger = logger;
        }

        private int GetUserId()
        {
            var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            return int.Parse(userIdClaim!);
        }

        /// Get all notes for current user

        [HttpGet]
        [ProducesResponseType(typeof(ApiResponse<IEnumerable<NoteResponseDto>>), StatusCodes.Status200OK)]
        public async Task<IActionResult> GetAll()
        {
            var userId = GetUserId();
            _logger.LogInformation("Fetching all notes for user: {UserId}", userId);

            var notes = await _noteService.GetAllAsync(userId);

            return Ok(ApiResponse<IEnumerable<NoteResponseDto>>.SuccessResponse(
                notes, $"Retrieved {notes.Count()} notes"));
        }


        /// Get note by ID

        [HttpGet("{id}")]
        [ProducesResponseType(typeof(ApiResponse<NoteResponseDto>), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status404NotFound)]
        public async Task<IActionResult> GetById(int id)
        {
            var userId = GetUserId();
            _logger.LogInformation("Fetching note {NoteId} for user: {UserId}", id, userId);

            var note = await _noteService.GetByIdAsync(id, userId);

            if (note == null)
            {
                return NotFound(new ErrorResponse("Note not found"));
            }

            return Ok(ApiResponse<NoteResponseDto>.SuccessResponse(note, "Note retrieved"));
        }


        /// Create new note

        [HttpPost]
        [ProducesResponseType(typeof(ApiResponse<NoteResponseDto>), StatusCodes.Status201Created)]
        [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status400BadRequest)]
        public async Task<IActionResult> Create([FromBody] CreateNoteDto dto)
        {
            var userId = GetUserId();
            _logger.LogInformation("Creating note for user: {UserId}", userId);

            var note = await _noteService.CreateAsync(dto, userId);

            _logger.LogInformation("Note created: {NoteId}", note.Id);

            return CreatedAtAction(
                nameof(GetById),
                new { id = note.Id },
                ApiResponse<NoteResponseDto>.SuccessResponse(note, "Note created successfully"));
        }

        /// Update note

        [HttpPut("{id}")]
        [ProducesResponseType(typeof(ApiResponse<NoteResponseDto>), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status404NotFound)]
        public async Task<IActionResult> Update(int id, [FromBody] UpdateNoteDto dto)
        {
            var userId = GetUserId();
            _logger.LogInformation("Updating note {NoteId} for user: {UserId}", id, userId);

            var note = await _noteService.UpdateAsync(id, dto, userId);

            _logger.LogInformation("Note updated: {NoteId}", id);

            return Ok(ApiResponse<NoteResponseDto>.SuccessResponse(note, "Note updated successfully"));
        }


        /// Delete note (soft delete)

        [HttpDelete("{id}")]
        [ProducesResponseType(typeof(ApiResponse), StatusCodes.Status200OK)]
        [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status404NotFound)]
        public async Task<IActionResult> Delete(int id)
        {
            var userId = GetUserId();
            _logger.LogInformation("Deleting note {NoteId} for user: {UserId}", id, userId);

            await _noteService.DeleteAsync(id, userId);

            _logger.LogInformation("Note deleted: {NoteId}", id);

            return Ok(ApiResponse.SuccessResponse("Note deleted successfully"));
        }


        /// Search notes

        [HttpGet("search")]
        [ProducesResponseType(typeof(ApiResponse<IEnumerable<NoteResponseDto>>), StatusCodes.Status200OK)]
        public async Task<IActionResult> Search([FromQuery] string query)
        {
            var userId = GetUserId();
            _logger.LogInformation("Searching notes for user {UserId} with query: {Query}", userId, query);

            var dto = new SearchNotesDto { Query = query };
            var notes = await _noteService.SearchAsync(dto, userId);

            return Ok(ApiResponse<IEnumerable<NoteResponseDto>>.SuccessResponse(
                notes, $"Found {notes.Count()} notes"));
        }

        /// Toggle pin status

        [HttpPatch("{id}/pin")]
        [ProducesResponseType(typeof(ApiResponse<NoteResponseDto>), StatusCodes.Status200OK)]
        public async Task<IActionResult> TogglePin(int id)
        {
            var userId = GetUserId();
            _logger.LogInformation("Toggling pin for note {NoteId}", id);

            var note = await _noteService.TogglePinAsync(id, userId);

            return Ok(ApiResponse<NoteResponseDto>.SuccessResponse(
                note, note.IsPinned ? "Note pinned" : "Note unpinned"));
        }

        /// Toggle archive status

        [HttpPatch("{id}/archive")]
        [ProducesResponseType(typeof(ApiResponse<NoteResponseDto>), StatusCodes.Status200OK)]
        public async Task<IActionResult> ToggleArchive(int id)
        {
            var userId = GetUserId();
            _logger.LogInformation("Toggling archive for note {NoteId}", id);

            var note = await _noteService.ToggleArchiveAsync(id, userId);

            return Ok(ApiResponse<NoteResponseDto>.SuccessResponse(
                note, note.IsArchived ? "Note archived" : "Note unarchived"));
        }

        /// Update note color
        [HttpPatch("{id}/color")]
        [ProducesResponseType(typeof(ApiResponse<NoteResponseDto>), StatusCodes.Status200OK)]
        public async Task<IActionResult> UpdateColor(int id, [FromBody] UpdateNoteColorDto dto)
        {
            var userId = GetUserId();
            _logger.LogInformation("Updating color for note {NoteId}", id);

            var note = await _noteService.UpdateColorAsync(id, dto, userId);

            return Ok(ApiResponse<NoteResponseDto>.SuccessResponse(note, "Note color updated"));
        }

        /// Bulk delete notes
        [HttpDelete("bulk")]
        [ProducesResponseType(typeof(ApiResponse), StatusCodes.Status200OK)]
        public async Task<IActionResult> BulkDelete([FromBody] BulkDeleteDto dto)
        {
            var userId = GetUserId();
            _logger.LogInformation("Bulk deleting {Count} notes for user: {UserId}",
                dto.NoteIds.Count(), userId);

            await _noteService.BulkDeleteAsync(dto, userId);

            return Ok(ApiResponse.SuccessResponse($"Deleted {dto.NoteIds.Count()} notes"));
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\FundooNotes\Extensions\ClaimsPrincipalExtensions.cs ==========
using System.Security.Claims;

namespace FundooNotes.Extensions
{
    public static class ClaimsPrincipalExtensions
    {
        public static int GetUserId(this ClaimsPrincipal principal)
        {
            var userIdClaim = principal.FindFirst(ClaimTypes.NameIdentifier)?.Value;

            if (string.IsNullOrEmpty(userIdClaim))
            {
                throw new UnauthorizedAccessException("User ID not found in token");
            }

            if (!int.TryParse(userIdClaim, out int userId))
            {
                throw new UnauthorizedAccessException("Invalid user ID format");
            }

            return userId;
        }

        public static string GetEmail(this ClaimsPrincipal principal)
        {
            var email = principal.FindFirst(ClaimTypes.Email)?.Value;

            if (string.IsNullOrEmpty(email))
            {
                throw new UnauthorizedAccessException("Email not found in token");
            }

            return email;
        }

        public static bool IsAuthenticated(this ClaimsPrincipal principal)
        {
            return principal.Identity?.IsAuthenticated ?? false;
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\FundooNotes\Extensions\ServiceExtensions.cs ==========
using BusinessLayer.Interfaces.Services;
using BusinessLayer.Services;
using DataBaseLayer.Context;
using DataBaseLayer.Interfaces;
using DataBaseLayer.Repositories;
using FundooNotes.Helpers;
using Microsoft.EntityFrameworkCore;

namespace FundooNotes.Extensions
{
    public static class ServiceExtensions
    {
        public static IServiceCollection AddApplicationServices(
            this IServiceCollection services,
            IConfiguration configuration)
        {
            // Add DbContext
            services.AddDbContext<FundooAppDbContext>(options =>
            {
                options.UseSqlServer(
                    configuration.GetConnectionString("DefaultConnection"),
                    sqlOptions =>
                    {
                        sqlOptions.EnableRetryOnFailure(
                            maxRetryCount: 3,
                            maxRetryDelay: TimeSpan.FromSeconds(5),
                            errorNumbersToAdd: null);
                        sqlOptions.CommandTimeout(30);
                    });

                // Enable sensitive data logging only in development
                if (Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") == "Development")
                {
                    options.EnableSensitiveDataLogging();
                    options.EnableDetailedErrors();
                }
            });

            // Register Repositories
            services.AddScoped<IUserRepository, UserRepository>();
            services.AddScoped<INoteRepository, NoteRepository>();
            services.AddScoped<ILabelRepository, LabelRepository>();
            services.AddScoped<ICollaboratorRepository, CollaboratorRepository>();

            // Register Services
            services.AddScoped<IAuthService, AuthService>();
            services.AddScoped<INoteService, NoteService>();
            services.AddScoped<ILabelService, LabelService>();
            services.AddScoped<ICollaboratorService, CollaboratorService>();

            // Register Helpers
            services.AddScoped<JwtTokenGenerator>();
            services.AddScoped<OtpEmailSender>();

            // Add Memory Cache
            services.AddMemoryCache();

            // Add HTTP Context Accessor
            services.AddHttpContextAccessor();

            return services;
        }

        public static IServiceCollection AddSwaggerDocumentation(this IServiceCollection services)
        {
            services.AddEndpointsApiExplorer();
            services.AddSwaggerGen(options =>
            {
                options.SwaggerDoc("v1", new Microsoft.OpenApi.Models.OpenApiInfo
                {
                    Title = "Fundoo Notes API",
                    Version = "v1",
                    Description = "A comprehensive note-taking application with real-time collaboration features",
                    Contact = new Microsoft.OpenApi.Models.OpenApiContact
                    {
                        Name = "Fundoo Notes Support",
                        Email = "support@fundoonotes.com",
                        Url = new Uri("https://fundoonotes.com")
                    },
                    License = new Microsoft.OpenApi.Models.OpenApiLicense
                    {
                        Name = "MIT License",
                        Url = new Uri("https://opensource.org/licenses/MIT")
                    }
                });

                // Add JWT Authentication to Swagger
                options.AddSecurityDefinition("Bearer", new Microsoft.OpenApi.Models.OpenApiSecurityScheme
                {
                    Name = "Authorization",
                    Type = Microsoft.OpenApi.Models.SecuritySchemeType.Http,
                    Scheme = "Bearer",
                    BearerFormat = "JWT",
                    In = Microsoft.OpenApi.Models.ParameterLocation.Header,
                    Description = "Enter 'Bearer' followed by a space and your JWT token. Example: 'Bearer eyJhbGc...'",
                });

                options.AddSecurityRequirement(new Microsoft.OpenApi.Models.OpenApiSecurityRequirement
                {
                    {
                        new Microsoft.OpenApi.Models.OpenApiSecurityScheme
                        {
                            Reference = new Microsoft.OpenApi.Models.OpenApiReference
                            {
                                Type = Microsoft.OpenApi.Models.ReferenceType.SecurityScheme,
                                Id = "Bearer"
                            }
                        },
                        Array.Empty<string>()
                    }
                });

                // Enable XML comments (optional)
                // var xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
                // var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
                // options.IncludeXmlComments(xmlPath);
            });

            return services;
        }

        public static IServiceCollection AddCustomCors(this IServiceCollection services)
        {
            services.AddCors(options =>
            {
                options.AddPolicy("AllowAll", builder =>
                {
                    builder.AllowAnyOrigin()
                           .AllowAnyMethod()
                           .AllowAnyHeader();
                });

                options.AddPolicy("Production", builder =>
                {
                    builder.WithOrigins(
                            "https://fundoonotes.com",
                            "https://www.fundoonotes.com")
                           .AllowAnyMethod()
                           .AllowAnyHeader()
                           .AllowCredentials();
                });
            });

            return services;
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\FundooNotes\Helpers\JwtTokenGenerator.cs ==========
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

namespace FundooNotes.Helpers
{
    public class JwtTokenGenerator
    {
        private readonly IConfiguration _configuration;
        private readonly ILogger<JwtTokenGenerator> _logger;

        public JwtTokenGenerator(IConfiguration configuration, ILogger<JwtTokenGenerator> logger)
        {
            _configuration = configuration;
            _logger = logger;
        }

        public string GenerateToken(int userId, string email)
        {
            try
            {
                var jwtSettings = _configuration.GetSection("Jwt");
                var key = Encoding.UTF8.GetBytes(jwtSettings["Key"]!);
                var issuer = jwtSettings["Issuer"];
                var audience = jwtSettings["Audience"];
                var expiryMinutes = int.Parse(jwtSettings["ExpiryMinutes"]!);

                var claims = new[]
                {
                    new Claim(ClaimTypes.NameIdentifier, userId.ToString()),
                    new Claim(ClaimTypes.Email, email),
                    new Claim(JwtRegisteredClaimNames.Sub, userId.ToString()),
                    new Claim(JwtRegisteredClaimNames.Email, email),
                    new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
                    new Claim(JwtRegisteredClaimNames.Iat, DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString(), ClaimValueTypes.Integer64)
                };

                var securityKey = new SymmetricSecurityKey(key);
                var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256);

                var token = new JwtSecurityToken(
                    issuer: issuer,
                    audience: audience,
                    claims: claims,
                    expires: DateTime.UtcNow.AddMinutes(expiryMinutes),
                    signingCredentials: credentials
                );

                var tokenString = new JwtSecurityTokenHandler().WriteToken(token);

                _logger.LogInformation("JWT token generated for user: {UserId}", userId);

                return tokenString;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error generating JWT token for user: {UserId}", userId);
                throw new InvalidOperationException("Failed to generate authentication token", ex);
            }
        }

        public ClaimsPrincipal? ValidateToken(string token)
        {
            try
            {
                var jwtSettings = _configuration.GetSection("Jwt");
                var key = Encoding.UTF8.GetBytes(jwtSettings["Key"]!);

                var tokenHandler = new JwtSecurityTokenHandler();
                var validationParameters = new TokenValidationParameters
                {
                    ValidateIssuer = true,
                    ValidateAudience = true,
                    ValidateLifetime = true,
                    ValidateIssuerSigningKey = true,
                    ValidIssuer = jwtSettings["Issuer"],
                    ValidAudience = jwtSettings["Audience"],
                    IssuerSigningKey = new SymmetricSecurityKey(key),
                    ClockSkew = TimeSpan.Zero
                };

                var principal = tokenHandler.ValidateToken(token, validationParameters, out var validatedToken);

                if (validatedToken is not JwtSecurityToken jwtToken ||
                    !jwtToken.Header.Alg.Equals(SecurityAlgorithms.HmacSha256, StringComparison.InvariantCultureIgnoreCase))
                {
                    return null;
                }

                return principal;
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Token validation failed");
                return null;
            }
        }

        public int? GetUserIdFromToken(string token)
        {
            var principal = ValidateToken(token);
            var userIdClaim = principal?.FindFirst(ClaimTypes.NameIdentifier)?.Value;

            return int.TryParse(userIdClaim, out int userId) ? userId : null;
        }

        public string? GetEmailFromToken(string token)
        {
            var principal = ValidateToken(token);
            return principal?.FindFirst(ClaimTypes.Email)?.Value;
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\FundooNotes\Helpers\OtpEmailSender.cs ==========
using System.Net;
using System.Net.Mail;

namespace FundooNotes.Helpers
{
    public class OtpEmailSender
    {
        private readonly IConfiguration _configuration;
        private readonly ILogger<OtpEmailSender> _logger;

        public OtpEmailSender(IConfiguration configuration, ILogger<OtpEmailSender> logger)
        {
            _configuration = configuration;
            _logger = logger;
        }

        public async Task SendOtpEmailAsync(string toEmail, string userName, string otp)
        {
            try
            {
                var smtpSettings = _configuration.GetSection("Smtp");
                var host = smtpSettings["Host"];
                var port = int.Parse(smtpSettings["Port"]!);
                var enableSsl = bool.Parse(smtpSettings["EnableSsl"]!);
                var username = smtpSettings["UserName"];
                var password = smtpSettings["Password"];
                var fromName = smtpSettings["From"];

                var subject = "Verify Your Email - Fundoo Notes";
                var body = GenerateOtpEmailBody(userName, otp);

                using var smtpClient = new SmtpClient(host, port)
                {
                    EnableSsl = enableSsl,
                    Credentials = new NetworkCredential(username, password)
                };

                var mailMessage = new MailMessage
                {
                    From = new MailAddress(username!, fromName),
                    Subject = subject,
                    Body = body,
                    IsBodyHtml = true
                };

                mailMessage.To.Add(toEmail);

                await smtpClient.SendMailAsync(mailMessage);

                _logger.LogInformation("OTP email sent successfully to: {Email}", toEmail);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to send OTP email to: {Email}", toEmail);
                throw new InvalidOperationException("Failed to send verification email", ex);
            }
        }

        public async Task SendPasswordResetEmailAsync(string toEmail, string userName, string resetToken)
        {
            try
            {
                var smtpSettings = _configuration.GetSection("Smtp");
                var host = smtpSettings["Host"];
                var port = int.Parse(smtpSettings["Port"]!);
                var enableSsl = bool.Parse(smtpSettings["EnableSsl"]!);
                var username = smtpSettings["UserName"];
                var password = smtpSettings["Password"];
                var fromName = smtpSettings["From"];

                var subject = "Reset Your Password - Fundoo Notes";
                var body = GeneratePasswordResetEmailBody(userName, resetToken);

                using var smtpClient = new SmtpClient(host, port)
                {
                    EnableSsl = enableSsl,
                    Credentials = new NetworkCredential(username, password)
                };

                var mailMessage = new MailMessage
                {
                    From = new MailAddress(username!, fromName),
                    Subject = subject,
                    Body = body,
                    IsBodyHtml = true
                };

                mailMessage.To.Add(toEmail);

                await smtpClient.SendMailAsync(mailMessage);

                _logger.LogInformation("Password reset email sent successfully to: {Email}", toEmail);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to send password reset email to: {Email}", toEmail);
                throw new InvalidOperationException("Failed to send password reset email", ex);
            }
        }

        private static string GenerateOtpEmailBody(string userName, string otp)
        {
            return $@"
<!DOCTYPE html>
<html>
<head>
    <style>
        body {{ font-family: Arial, sans-serif; background-color: #f4f4f4; padding: 20px; }}
        .container {{ background-color: #ffffff; border-radius: 10px; padding: 30px; max-width: 600px; margin: 0 auto; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
        .header {{ text-align: center; color: #4A90E2; margin-bottom: 30px; }}
        .otp-box {{ background-color: #f0f8ff; border: 2px dashed #4A90E2; border-radius: 8px; padding: 20px; text-align: center; margin: 20px 0; }}
        .otp-code {{ font-size: 32px; font-weight: bold; color: #4A90E2; letter-spacing: 5px; }}
        .footer {{ text-align: center; color: #888; font-size: 12px; margin-top: 30px; }}
        .warning {{ color: #e74c3c; font-size: 14px; margin-top: 15px; }}
    </style>
</head>
<body>
    <div class='container'>
        <div class='header'>
            <h1>📝 Fundoo Notes</h1>
            <h2>Email Verification</h2>
        </div>
        <p>Hi <strong>{userName}</strong>,</p>
        <p>Thank you for registering with Fundoo Notes! To complete your registration, please use the following One-Time Password (OTP):</p>
        
        <div class='otp-box'>
            <div class='otp-code'>{otp}</div>
        </div>
        
        <p>This OTP will expire in <strong>10 minutes</strong>.</p>
        <p class='warning'>⚠️ Do not share this OTP with anyone. Our team will never ask for your OTP.</p>
        
        <p>If you didn't request this verification, please ignore this email.</p>
        
        <div class='footer'>
            <p>© 2026 Fundoo Notes. All rights reserved.</p>
            <p>This is an automated email. Please do not reply.</p>
        </div>
    </div>
</body>
</html>";
        }

        private static string GeneratePasswordResetEmailBody(string userName, string resetToken)
        {
            // In production, this should be a proper frontend URL
            var resetLink = $"https://fundoonotes.com/reset-password?token={resetToken}";

            return $@"
<!DOCTYPE html>
<html>
<head>
    <style>
        body {{ font-family: Arial, sans-serif; background-color: #f4f4f4; padding: 20px; }}
        .container {{ background-color: #ffffff; border-radius: 10px; padding: 30px; max-width: 600px; margin: 0 auto; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
        .header {{ text-align: center; color: #4A90E2; margin-bottom: 30px; }}
        .button {{ display: inline-block; background-color: #4A90E2; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; }}
        .token-box {{ background-color: #f0f8ff; border-radius: 8px; padding: 15px; margin: 20px 0; word-break: break-all; }}
        .footer {{ text-align: center; color: #888; font-size: 12px; margin-top: 30px; }}
        .warning {{ color: #e74c3c; font-size: 14px; margin-top: 15px; }}
    </style>
</head>
<body>
    <div class='container'>
        <div class='header'>
            <h1>📝 Fundoo Notes</h1>
            <h2>Password Reset Request</h2>
        </div>
        <p>Hi <strong>{userName}</strong>,</p>
        <p>We received a request to reset your password. Click the button below to reset it:</p>
        
        <div style='text-align: center;'>
            <a href='{resetLink}' class='button'>Reset Password</a>
        </div>
        
        <p>Or copy and paste this link into your browser:</p>
        <div class='token-box'>
            <small>{resetLink}</small>
        </div>
        
        <p>Your reset token: <strong>{resetToken}</strong></p>
        <p>This link will expire in <strong>15 minutes</strong>.</p>
        
        <p class='warning'>⚠️ If you didn't request a password reset, please ignore this email or contact support if you have concerns.</p>
        
        <div class='footer'>
            <p>© 2026 Fundoo Notes. All rights reserved.</p>
            <p>This is an automated email. Please do not reply.</p>
        </div>
    </div>
</body>
</html>";
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\FundooNotes\Helpers\PasswordHasher.cs ==========
namespace FundooNotes.Helpers
{
    public static class PasswordHasher
    {
        public static string HashPassword(string password)
        {
            if (string.IsNullOrEmpty(password))
            {
                throw new ArgumentNullException(nameof(password));
            }

            return BCrypt.Net.BCrypt.HashPassword(password, workFactor: 12);
        }

        public static bool VerifyPassword(string password, string hashedPassword)
        {
            if (string.IsNullOrEmpty(password))
            {
                throw new ArgumentNullException(nameof(password));
            }

            if (string.IsNullOrEmpty(hashedPassword))
            {
                throw new ArgumentNullException(nameof(hashedPassword));
            }

            try
            {
                return BCrypt.Net.BCrypt.Verify(password, hashedPassword);
            }
            catch
            {
                return false;
            }
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\FundooNotes\Helpers\ResponseHelper.cs ==========
using ModelLayer.Responses;

namespace FundooNotes.Helpers
{
    public static class ResponseHelper
    {
        public static ApiResponse<T> Success<T>(T data, string message = "Success")
        {
            return ApiResponse<T>.SuccessResponse(data, message);
        }

        public static ApiResponse Success(string message = "Success")
        {
            return ApiResponse.SuccessResponse(message);
        }

        public static ErrorResponse Error(string message, string? errorCode = null)
        {
            return new ErrorResponse(message, errorCode ?? "ERROR");
        }

        public static ErrorResponse ValidationError(string message, Dictionary<string, string[]> errors)
        {
            return new ErrorResponse(message, errors);
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\FundooNotes\Middleware\GlobalExceptionMiddleware.cs ==========
using BusinessLayer.Exceptions;
using ModelLayer.Responses;
using System.Net;
using System.Text.Json;

namespace FundooNotes.Middleware
{
    public class GlobalExceptionMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<GlobalExceptionMiddleware> _logger;
        private readonly IHostEnvironment _environment;

        public GlobalExceptionMiddleware(
            RequestDelegate next,
            ILogger<GlobalExceptionMiddleware> logger,
            IHostEnvironment environment)
        {
            _next = next;
            _logger = logger;
            _environment = environment;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            try
            {
                await _next(context);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "An unhandled exception occurred: {Message}", ex.Message);
                await HandleExceptionAsync(context, ex);
            }
        }

        private Task HandleExceptionAsync(HttpContext context, Exception exception)
        {
            context.Response.ContentType = "application/json";

            ErrorResponse errorResponse;
            HttpStatusCode statusCode;

            switch (exception)
            {
                case ValidationException validationEx:
                    statusCode = HttpStatusCode.BadRequest;
                    errorResponse = new ErrorResponse
                    {
                        Success = false,
                        Message = validationEx.Message,
                        ErrorCode = "VALIDATION_ERROR",
                        ValidationErrors = validationEx.Errors
                    };
                    break;

                case NotFoundException notFoundEx:
                    statusCode = HttpStatusCode.NotFound;
                    errorResponse = new ErrorResponse
                    {
                        Success = false,
                        Message = notFoundEx.Message,
                        ErrorCode = "NOT_FOUND"
                    };
                    break;

                case UnauthorizedException unauthorizedEx:
                    statusCode = HttpStatusCode.Unauthorized;
                    errorResponse = new ErrorResponse
                    {
                        Success = false,
                        Message = unauthorizedEx.Message,
                        ErrorCode = "UNAUTHORIZED"
                    };
                    break;

                case ArgumentNullException argNullEx:
                    statusCode = HttpStatusCode.BadRequest;
                    errorResponse = new ErrorResponse
                    {
                        Success = false,
                        Message = $"Required parameter '{argNullEx.ParamName}' is missing",
                        ErrorCode = "MISSING_PARAMETER"
                    };
                    break;

                case ArgumentException argEx:
                    statusCode = HttpStatusCode.BadRequest;
                    errorResponse = new ErrorResponse
                    {
                        Success = false,
                        Message = argEx.Message,
                        ErrorCode = "INVALID_ARGUMENT"
                    };
                    break;

                case InvalidOperationException invalidOpEx:
                    statusCode = HttpStatusCode.BadRequest;
                    errorResponse = new ErrorResponse
                    {
                        Success = false,
                        Message = invalidOpEx.Message,
                        ErrorCode = "INVALID_OPERATION"
                    };
                    break;

                case TimeoutException timeoutEx:
                    statusCode = HttpStatusCode.RequestTimeout;
                    errorResponse = new ErrorResponse
                    {
                        Success = false,
                        Message = "The request timed out. Please try again.",
                        ErrorCode = "TIMEOUT"
                    };
                    break;

                default:
                    statusCode = HttpStatusCode.InternalServerError;
                    errorResponse = new ErrorResponse
                    {
                        Success = false,
                        Message = _environment.IsDevelopment()
                            ? exception.Message
                            : "An internal server error occurred. Please try again later.",
                        ErrorCode = "INTERNAL_ERROR"
                    };

                    // Include stack trace only in development
                    if (_environment.IsDevelopment())
                    {
                        errorResponse.StackTrace = exception.StackTrace;
                    }
                    break;
            }

            context.Response.StatusCode = (int)statusCode;

            var options = new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                WriteIndented = _environment.IsDevelopment()
            };

            var json = JsonSerializer.Serialize(errorResponse, options);

            return context.Response.WriteAsync(json);
        }
    }

    // Extension method to register middleware
    public static class GlobalExceptionMiddlewareExtensions
    {
        public static IApplicationBuilder UseGlobalExceptionHandler(this IApplicationBuilder app)
        {
            return app.UseMiddleware<GlobalExceptionMiddleware>();
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\FundooNotes\Properties\launchSettings.json ==========
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "http://localhost:5233",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "https://localhost:7014;http://localhost:5233",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\Configuration\AppSettings.cs ==========
namespace ModelLayer.Configuration
{
    public class AppSettings
    {
        public string ApplicationName { get; set; } = null!;
        public string ApplicationUrl { get; set; } = null!;
        public int MaxLoginAttempts { get; set; }
        public int AccountLockoutMinutes { get; set; }
        public int OtpExpiryMinutes { get; set; }
        public int PasswordResetExpiryMinutes { get; set; }
        public int MaxNotesPerUser { get; set; }
        public int MaxLabelsPerUser { get; set; }
        public int MaxCollaboratorsPerNote { get; set; }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\Configuration\CorsSettings.cs ==========
namespace ModelLayer.Configuration
{
    public class CorsSettings
    {
        public string[] AllowedOrigins { get; set; } = Array.Empty<string>();
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\Configuration\JwtSettings.cs ==========

namespace ModelLayer.Configuration
{
    public class JwtSettings
    {
        public string Key { get; set; } = null!;
        public string Issuer { get; set; } = null!;
        public string Audience { get; set; } = null!;
        public int AccessTokenExpiryMinutes { get; set; }
        public int RefreshTokenExpiryDays { get; set; }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\Configuration\SecuritySettings.cs ==========

namespace ModelLayer.Configuration
{
    public class SecuritySettings
    {
        public bool RequireHttpsMetadata { get; set; }
        public bool SaveToken { get; set; }
        public bool ValidateIssuer { get; set; }
        public bool ValidateAudience { get; set; }
        public bool ValidateLifetime { get; set; }
        public bool ValidateIssuerSigningKey { get; set; }
        public int ClockSkew { get; set; }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\Configuration\SmtpSettings.cs ==========
namespace ModelLayer.Configuration
{
    public class SmtpSettings
    {
        public string Host { get; set; } = null!;
        public int Port { get; set; }
        public bool EnableSsl { get; set; }
        public string UserName { get; set; } = null!;
        public string Password { get; set; } = null!;
        public string FromName { get; set; } = null!;
        public string FromEmail { get; set; } = null!;
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\Domain\CollaboratorModel.cs ==========
using ModelLayer.Enums;


namespace ModelLayer.Domain
{
    public class CollaboratorModel
    {
        public int Id { get; set; }
        public int NoteId { get; set; }
        public int UserId { get; set; }
        public string UserEmail { get; set; } = null!;
        public string? UserName { get; set; }
        public PermissionLevel Permission { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\Domain\LabelModel.cs ==========
namespace ModelLayer.Domain
{
    public class LabelModel
    {
        public int Id { get; set; }
        public string Name { get; set; } = null!;
        public DateTime CreatedAt { get; set; }
        public int UserId { get; set; }
        public int NotesCount { get; set; }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\Domain\NoteModel.cs ==========


namespace ModelLayer.Domain
{
    public class NoteModel
{
    public int Id { get; set; }
    public string Title { get; set; } = null!;
    public string Content { get; set; } = null!;
    public string Color { get; set; } = null!;
    public bool IsPinned { get; set; }
    public bool IsArchived { get; set; }
    public bool IsDeleted { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? UpdatedAt { get; set; }
    public int UserId { get; set; }
    public string? UserName { get; set; }
    public string? UserEmail { get; set; }
    public List<LabelModel>? Labels { get; set; }
    public List<CollaboratorModel>? Collaborators { get; set; }
}
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\Domain\UserModel.cs ==========
namespace ModelLayer.Domain
{
    public class UserModel
    {
        public int Id { get; set; }
        public string Name { get; set; } = null!;
        public string Email { get; set; } = null!;
        public bool IsEmailVerified { get; set; }
        public DateTime CreatedAt { get; set; }
        public DateTime? LastLoginAt { get; set; }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Auth\AuthResponseDto.cs ==========
namespace ModelLayer.DTOs.Auth
{
    public class AuthResponseDto
    {
        public int UserId { get; set; }
        public string Email { get; set; } = null!;
        public string? AccessToken { get; set; }
        public string? RefreshToken { get; set; }
        public int ExpiresIn { get; set; }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Auth\ForgotPasswordDto.cs ==========
namespace ModelLayer.DTOs.Auth
{
    public class ForgotPasswordDto
    {
        public string Email { get; set; } = null!;
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Auth\LoginRequestDto.cs ==========
namespace ModelLayer.DTOs.Auth
{
    public class LoginRequestDto
    {
        public string Email { get; set; } = null!;
        public string Password { get; set; } = null!;
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Auth\LoginResultDto.cs ==========
namespace ModelLayer.DTOs.Auth
{
    public class LoginResultDto
    {
        public int UserId { get; set; }
        public string Email { get; set; } = string.Empty;
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Auth\LogoutRequestDto.cs ==========
namespace ModelLayer.DTOs.Auth
{
    public class LogoutRequestDto
    {
        public int UserId { get; set; }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Auth\RefreshTokenDto.cs ==========
namespace ModelLayer.DTOs.Auth
{
    public class RefreshTokenDto
    {
        public string RefreshToken { get; set; } = null!;
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Auth\RegisterRequestDto.cs ==========
namespace ModelLayer.DTOs.Auth
{
    public class RegisterRequestDto
    {
        public string Name { get; set; } = null!;
        public string Email { get; set; } = null!;
        public string Password { get; set; } = null!;
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Auth\ResetPasswordDto.cs ==========
namespace ModelLayer.DTOs.Auth
{
    public class ResetPasswordDto
    {
        public string Token { get; set; } = null!;
        public string NewPassword { get; set; } = null!;
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Auth\VerifyOtpRequestDto.cs ==========
namespace ModelLayer.DTOs.Auth
{
    public class VerifyOtpRequestDto
    {
        public string Email { get; set; } = null!;
        public string Otp { get; set; } = null!;
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Collaborators\AddCollaboratorDto.cs ==========
using ModelLayer.Enums;

namespace ModelLayer.DTOs.Collaborators
{
    public class AddCollaboratorDto
    {
        public int NoteId { get; set; }
        public int UserId { get; set; }
        public PermissionLevel Permission { get; set; }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Collaborators\CollaboratorResponseDto.cs ==========
using ModelLayer.Enums;

namespace ModelLayer.DTOs.Collaborators
{
    public class CollaboratorResponseDto
    {
        public int Id { get; set; }
        public int NoteId { get; set; }
        public int UserId { get; set; }
        public string UserEmail { get; set; } = null!;
        public string? UserName { get; set; }
        public PermissionLevel Permission { get; set; }
        public DateTime CreatedAt { get; set; }
        public DateTime? UpdatedAt { get; set; }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Collaborators\UpdatePermissionDto.cs ==========
using ModelLayer.Enums;

namespace ModelLayer.DTOs.Collaborators
{
    public class UpdatePermissionDto
    {
        public PermissionLevel Permission { get; set; }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Labels\CreateLabelDto.cs ==========
namespace ModelLayer.DTOs.Labels
{
    public class CreateLabelDto
    {
        public string Name { get; set; } = null!;
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Labels\LabelResponseDto.cs ==========
namespace ModelLayer.DTOs.Labels
{
    public class LabelResponseDto
    {
        public int Id { get; set; }
        public string Name { get; set; } = null!;
        public DateTime CreatedAt { get; set; }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Labels\UpdateLabelDto.cs ==========
namespace ModelLayer.DTOs.Labels
{
    public class UpdateLabelDto
    {
        public string Name { get; set; } = null!;
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Notes\BulkDeleteDto.cs ==========
namespace ModelLayer.DTOs.Notes
{
    public class BulkDeleteDto
    {
        public IEnumerable<int> NoteIds { get; set; } = new List<int>();
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Notes\CreateNoteDto.cs ==========
namespace ModelLayer.DTOs.Notes
{
    public class CreateNoteDto
    {
        public string? Title { get; set; }
        public string? Content { get; set; }
        public string? Color { get; set; }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Notes\NoteResponseDto.cs ==========
namespace ModelLayer.DTOs.Notes
{
    public class NoteResponseDto
    {
        public int Id { get; set; }
        public string Title { get; set; } = null!;
        public string Content { get; set; } = null!;
        public string Color { get; set; } = null!;
        public bool IsPinned { get; set; }
        public bool IsArchived { get; set; }
        public DateTime CreatedAt { get; set; }
        public DateTime? UpdatedAt { get; set; }
        public List<LabelDto>? Labels { get; set; }
    }

    public class LabelDto
    {
        public int Id { get; set; }
        public string Name { get; set; } = null!;
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Notes\SearchNotesDto.cs ==========
namespace ModelLayer.DTOs.Notes
{
    public class SearchNotesDto
    {
        public string Query { get; set; } = null!;
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Notes\UpdateNoteColorDto.cs ==========
namespace ModelLayer.DTOs.Notes
{
    public class UpdateNoteColorDto
    {
        public string Color { get; set; } = null!;
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\DTOs\Notes\UpdateNoteDto.cs ==========
namespace ModelLayer.DTOs.Notes
{
    public class UpdateNoteDto
    {
        public string? Title { get; set; }
        public string? Content { get; set; }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\Enums\PermissionLevel.cs ==========
namespace ModelLayer.Enums
{
    public enum PermissionLevel
    {
        View = 0,
        Edit = 1
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\Responses\ApiResponse.cs ==========
namespace ModelLayer.Responses
{
    public class ApiResponse<T>
    {
        public bool Success { get; set; }
        public string Message { get; set; } = string.Empty;
        public T? Data { get; set; }
        public List<string>? Errors { get; set; }
        public DateTime Timestamp { get; set; }

        public ApiResponse()
        {
            Timestamp = DateTime.UtcNow;
        }

        public static ApiResponse<T> SuccessResponse(T data, string message = "Success")
        {
            return new ApiResponse<T>
            {
                Success = true,
                Message = message,
                Data = data
            };
        }

        public static ApiResponse<T> ErrorResponse(string message, List<string>? errors = null)
        {
            return new ApiResponse<T>
            {
                Success = false,
                Message = message,
                Errors = errors
            };
        }
    }

    public class ApiResponse
    {
        public bool Success { get; set; }
        public string Message { get; set; } = string.Empty;
        public List<string>? Errors { get; set; }
        public DateTime Timestamp { get; set; }

        public ApiResponse()
        {
            Timestamp = DateTime.UtcNow;
        }

        public static ApiResponse SuccessResponse(string message = "Success")
        {
            return new ApiResponse
            {
                Success = true,
                Message = message
            };
        }

        public static ApiResponse ErrorResponse(string message, List<string>? errors = null)
        {
            return new ApiResponse
            {
                Success = false,
                Message = message,
                Errors = errors
            };
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\Responses\ErrorResponse.cs ==========
// ========================================
// FILE: ModelLayer/Responses/ErrorResponse.cs (CORRECTED)
// ========================================
namespace ModelLayer.Responses
{
    public class ErrorResponse
    {
        public bool Success { get; set; } = false;
        public string Message { get; set; } = null!;
        public string? ErrorCode { get; set; }
        public Dictionary<string, string[]>? ValidationErrors { get; set; }
        public string? StackTrace { get; set; }
        public DateTime Timestamp { get; set; }

        public ErrorResponse()
        {
            Timestamp = DateTime.UtcNow;
        }

        public ErrorResponse(string message)
        {
            Message = message;
            Timestamp = DateTime.UtcNow;
        }

        public ErrorResponse(string message, string errorCode)
        {
            Message = message;
            ErrorCode = errorCode;
            Timestamp = DateTime.UtcNow;
        }

        public ErrorResponse(string message, Dictionary<string, string[]> validationErrors)
        {
            Message = message;
            ValidationErrors = validationErrors;
            Timestamp = DateTime.UtcNow;
        }

        // ✅ RENAMED METHOD (was ErrorResponse, now Create)
        public static ErrorResponse Create(string message, string errorCode = "ERROR")
        {
            return new ErrorResponse(message, errorCode);
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\Responses\PaginatedResponse.cs ==========
namespace ModelLayer.Responses
{
    public class PaginatedResponse<T>
    {
        public bool Success { get; set; }
        public string Message { get; set; } = string.Empty;
        public IEnumerable<T>? Data { get; set; }
        public int TotalCount { get; set; }
        public int PageNumber { get; set; }
        public int PageSize { get; set; }
        public int TotalPages { get; set; }
        public bool HasPreviousPage { get; set; }
        public bool HasNextPage { get; set; }
        public DateTime Timestamp { get; set; }

        public PaginatedResponse()
        {
            Timestamp = DateTime.UtcNow;
        }

        public static PaginatedResponse<T> Create(
            IEnumerable<T> data,
            int totalCount,
            int pageNumber,
            int pageSize,
            string message = "Success")
        {
            var totalPages = (int)Math.Ceiling(totalCount / (double)pageSize);

            return new PaginatedResponse<T>
            {
                Success = true,
                Message = message,
                Data = data,
                TotalCount = totalCount,
                PageNumber = pageNumber,
                PageSize = pageSize,
                TotalPages = totalPages,
                HasPreviousPage = pageNumber > 1,
                HasNextPage = pageNumber < totalPages
            };
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\Responses\PaginationRequest.cs ==========
namespace ModelLayer.Requests
{
    public class PaginationRequest
    {
        private const int MaxPageSize = 100;
        private int _pageSize = 10;

        public int PageNumber { get; set; } = 1;

        public int PageSize
        {
            get => _pageSize;
            set => _pageSize = value > MaxPageSize ? MaxPageSize : value;
        }

        public string? SortBy { get; set; }
        public bool SortDescending { get; set; } = true;
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\ModelLayer\Responses\SearchRequest.cs ==========
namespace ModelLayer.Requests
{
    public class SearchRequest : PaginationRequest
    {
        public string? Query { get; set; }
        public bool? IsPinned { get; set; }
        public bool? IsArchived { get; set; }
        public string? Color { get; set; }
        public List<int>? LabelIds { get; set; }
        public DateTime? CreatedFrom { get; set; }
        public DateTime? CreatedTo { get; set; }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\Testing\Integration\AuthControllerIntegrationTests.cs ==========
// ========================================
// FILE: Testing/Integration/AuthControllerIntegrationTests.cs
// ========================================
using FluentAssertions;
using ModelLayer.DTOs.Auth;
using ModelLayer.Responses;
using NUnit.Framework;
using System.Net;
using System.Net.Http.Json;

namespace Testing.Integration
{
    [TestFixture]
    public class AuthControllerIntegrationTests
    {
        private CustomWebApplicationFactory _factory = null!;
        private HttpClient _client = null!;

        [SetUp]
        public void Setup()
        {
            _factory = new CustomWebApplicationFactory();
            _client = _factory.CreateClient();
        }

        [TearDown]
        public void TearDown()
        {
            _client?.Dispose();
            _factory?.Dispose();
        }

        [Test]
        public async Task Register_ValidUser_ReturnsSuccess()
        {
            var registerDto = new RegisterRequestDto
            {
                Name = "John Doe",
                Email = "john.doe@example.com",
                Password = "SecurePass123"
            };

            var response = await _client.PostAsJsonAsync("/api/auth/register", registerDto);

            response.StatusCode.Should().Be(HttpStatusCode.OK);
            var result = await response.Content.ReadFromJsonAsync<ApiResponse<string>>();
            result.Should().NotBeNull();
            result!.Success.Should().BeTrue();
            result.Message.Should().Contain("Registration successful");
        }

        [Test]
        public async Task Register_DuplicateEmail_ReturnsBadRequest()
        {
            var registerDto = new RegisterRequestDto
            {
                Name = "Jane Doe",
                Email = "duplicate@example.com",
                Password = "SecurePass123"
            };

            await _client.PostAsJsonAsync("/api/auth/register", registerDto);

            var response = await _client.PostAsJsonAsync("/api/auth/register", registerDto);

            response.StatusCode.Should().Be(HttpStatusCode.BadRequest);
        }

        [Test]
        public async Task Login_InvalidCredentials_ReturnsUnauthorized()
        {
            var loginDto = new LoginRequestDto
            {
                Email = "nonexistent@example.com",
                Password = "WrongPassword123"
            };

            var response = await _client.PostAsJsonAsync("/api/auth/login", loginDto);

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }

        [Test]
        public async Task GetCurrentUser_WithoutToken_ReturnsUnauthorized()
        {
            var response = await _client.GetAsync("/api/auth/me");

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\Testing\Integration\CollaboratorControllerIntegrationTests.cs ==========
// ========================================
// FILE: Testing/Integration/CollaboratorControllerIntegrationTests.cs
// ========================================
using FluentAssertions;
using ModelLayer.DTOs.Collaborators;
using ModelLayer.Enums;
using NUnit.Framework;
using System.Net;
using System.Net.Http.Json;

namespace Testing.Integration
{
    [TestFixture]
    public class CollaboratorControllerIntegrationTests
    {
        private CustomWebApplicationFactory _factory = null!;
        private HttpClient _client = null!;

        [SetUp]
        public void Setup()
        {
            _factory = new CustomWebApplicationFactory();
            _client = _factory.CreateClient();
        }

        [TearDown]
        public void TearDown()
        {
            _client?.Dispose();
            _factory?.Dispose();
        }

        [Test]
        public async Task AddCollaborator_WithoutAuth_ReturnsUnauthorized()
        {
            var addDto = new AddCollaboratorDto
            {
                NoteId = 1,
                UserId = 2,
                Permission = PermissionLevel.View
            };

            var response = await _client.PostAsJsonAsync("/api/collaborators", addDto);

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }

        [Test]
        public async Task GetCollaborators_WithoutAuth_ReturnsUnauthorized()
        {
            var response = await _client.GetAsync("/api/collaborators/note/1");

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }

        [Test]
        public async Task UpdatePermission_WithoutAuth_ReturnsUnauthorized()
        {
            var updateDto = new UpdatePermissionDto { Permission = PermissionLevel.Edit };

            var response = await _client.PutAsJsonAsync("/api/collaborators/1", updateDto);

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }

        [Test]
        public async Task RemoveCollaborator_WithoutAuth_ReturnsUnauthorized()
        {
            var response = await _client.DeleteAsync("/api/collaborators/1");

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }

        [Test]
        public async Task AddCollaborator_InvalidNoteId_ReturnsUnauthorized()
        {
            var addDto = new AddCollaboratorDto
            {
                NoteId = 0,
                UserId = 2,
                Permission = PermissionLevel.View
            };

            var response = await _client.PostAsJsonAsync("/api/collaborators", addDto);

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }

        [Test]
        public async Task AddCollaborator_InvalidUserId_ReturnsUnauthorized()
        {
            var addDto = new AddCollaboratorDto
            {
                NoteId = 1,
                UserId = 0,
                Permission = PermissionLevel.View
            };

            var response = await _client.PostAsJsonAsync("/api/collaborators", addDto);

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }

        [Test]
        public async Task GetCollaborators_InvalidNoteId_ReturnsUnauthorized()
        {
            var response = await _client.GetAsync("/api/collaborators/note/999");

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }

        [Test]
        public async Task UpdatePermission_InvalidCollaboratorId_ReturnsUnauthorized()
        {
            var updateDto = new UpdatePermissionDto { Permission = PermissionLevel.Edit };

            var response = await _client.PutAsJsonAsync("/api/collaborators/999", updateDto);

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }

        [Test]
        public async Task RemoveCollaborator_InvalidCollaboratorId_ReturnsUnauthorized()
        {
            var response = await _client.DeleteAsync("/api/collaborators/999");

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\Testing\Integration\CustomWebApplicationFactory.cs ==========

using DataBaseLayer.Context;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.VisualStudio.TestPlatform.TestHost;

namespace Testing.Integration
{
    public class CustomWebApplicationFactory : WebApplicationFactory<Program>
    {
        protected override void ConfigureWebHost(IWebHostBuilder builder)
        {
            builder.ConfigureServices(services =>
            {
                // Remove the existing DbContext registration
                var descriptor = services.SingleOrDefault(
                    d => d.ServiceType == typeof(DbContextOptions<FundooAppDbContext>));

                if (descriptor != null)
                {
                    services.Remove(descriptor);
                }

                // Add InMemory database for testing
                services.AddDbContext<FundooAppDbContext>(options =>
                {
                    options.UseInMemoryDatabase("TestDatabase");
                });

                // Build service provider
                var sp = services.BuildServiceProvider();

                // Create a scope to obtain a reference to the database context
                using var scope = sp.CreateScope();
                var scopedServices = scope.ServiceProvider;
                var db = scopedServices.GetRequiredService<FundooAppDbContext>();

                // Ensure the database is created
                db.Database.EnsureCreated();
            });

            builder.UseEnvironment("Testing");
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\Testing\Integration\LabelControllerIntegrationTests.cs ==========
// ========================================
// FILE: Testing/Integration/LabelControllerIntegrationTests.cs
// ========================================
using FluentAssertions;
using ModelLayer.DTOs.Labels;
using NUnit.Framework;
using System.Net;
using System.Net.Http.Json;

namespace Testing.Integration
{
    [TestFixture]
    public class LabelControllerIntegrationTests
    {
        private CustomWebApplicationFactory _factory = null!;
        private HttpClient _client = null!;

        [SetUp]
        public void Setup()
        {
            _factory = new CustomWebApplicationFactory();
            _client = _factory.CreateClient();
        }

        [TearDown]
        public void TearDown()
        {
            _client?.Dispose();
            _factory?.Dispose();
        }

        [Test]
        public async Task CreateLabel_WithoutAuth_ReturnsUnauthorized()
        {
            var createDto = new CreateLabelDto { Name = "Work" };

            var response = await _client.PostAsJsonAsync("/api/labels", createDto);

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }

        [Test]
        public async Task GetAllLabels_WithoutAuth_ReturnsUnauthorized()
        {
            var response = await _client.GetAsync("/api/labels");

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }

        [Test]
        public async Task GetLabelById_WithoutAuth_ReturnsUnauthorized()
        {
            var response = await _client.GetAsync("/api/labels/1");

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }

        [Test]
        public async Task UpdateLabel_WithoutAuth_ReturnsUnauthorized()
        {
            var updateDto = new UpdateLabelDto { Name = "Updated" };

            var response = await _client.PutAsJsonAsync("/api/labels/1", updateDto);

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }

        [Test]
        public async Task DeleteLabel_WithoutAuth_ReturnsUnauthorized()
        {
            var response = await _client.DeleteAsync("/api/labels/1");

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }

        [Test]
        public async Task GetLabelById_NonExistent_ReturnsUnauthorized()
        {
            var response = await _client.GetAsync("/api/labels/999");

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }

        [Test]
        public async Task CreateLabel_EmptyName_ReturnsUnauthorized()
        {
            var createDto = new CreateLabelDto { Name = "" };

            var response = await _client.PostAsJsonAsync("/api/labels", createDto);

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }

        [Test]
        public async Task UpdateLabel_EmptyName_ReturnsUnauthorized()
        {
            var updateDto = new UpdateLabelDto { Name = "" };

            var response = await _client.PutAsJsonAsync("/api/labels/1", updateDto);

            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\Testing\Integration\NoteControllerIntegrationTests.cs ==========

using DataBaseLayer.Context;
using DataBaseLayer.Entities;
using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using ModelLayer.DTOs.Notes;
using ModelLayer.Responses;
using NUnit.Framework;
using System.Net;
using System.Net.Http.Headers;
using System.Net.Http.Json;

namespace Testing.Integration
{
    [TestFixture]
    public class NoteControllerIntegrationTests
    {
        private CustomWebApplicationFactory _factory;
        private HttpClient _client;
        private string _authToken;
        private int _userId;

        [SetUp]
        public async Task Setup()
        {
            _factory = new CustomWebApplicationFactory();
            _client = _factory.CreateClient();

            // Setup test user and get auth token
            await SetupTestUserWithToken();
        }

        [TearDown]
        public void TearDown()
        {
            _client?.Dispose();
            _factory?.Dispose();
        }

        private async Task SetupTestUserWithToken()
        {
            using var scope = _factory.Services.CreateScope();
            var dbContext = scope.ServiceProvider.GetRequiredService<FundooAppDbContext>();

            // Create test user
            var user = new User
            {
                Name = "Test User",
                Email = "testuser@example.com",
                PasswordHash = BCrypt.Net.BCrypt.HashPassword("Test123"),
                IsEmailVerified = true,
                CreatedAt = DateTime.UtcNow
            };

            dbContext.Users.Add(user);
            await dbContext.SaveChangesAsync();

            _userId = user.Id;

            // Generate mock JWT token (simplified)
            _authToken = "mock-jwt-token"; // In real tests, generate valid JWT
            _client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", _authToken);
        }

        // Create Note Tests
        [Test]
        public async Task CreateNote_ValidData_ReturnsSuccess()
        {
            // Arrange
            var createDto = new CreateNoteDto
            {
                Title = "Test Note",
                Content = "This is test content",
                Color = "#FFFFFF"
            };

            // Act
            var response = await _client.PostAsJsonAsync("/api/notes", createDto);

            // Assert
            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized); // No valid JWT
        }

        [Test]
        public async Task CreateNote_EmptyTitleAndContent_ReturnsBadRequest()
        {
            // Arrange
            var createDto = new CreateNoteDto
            {
                Title = "",
                Content = ""
            };

            // Act
            var response = await _client.PostAsJsonAsync("/api/notes", createDto);

            // Assert
            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized); // No valid JWT
        }

        // GetAllNotes Tests
        [Test]
        public async Task GetAllNotes_WithoutAuth_ReturnsUnauthorized()
        {
            // Arrange
            _client.DefaultRequestHeaders.Authorization = null;

            // Act
            var response = await _client.GetAsync("/api/notes");

            // Assert
            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        }

        // GetNoteById Tests
        [Test]
        public async Task GetNoteById_NonExistent_ReturnsNotFound()
        {
            // Act
            var response = await _client.GetAsync("/api/notes/999");

            // Assert
            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized); // No valid JWT
        }

        // Update Note Tests
        [Test]
        public async Task UpdateNote_ValidData_ReturnsSuccess()
        {
            // Arrange
            var updateDto = new UpdateNoteDto
            {
                Title = "Updated Title",
                Content = "Updated Content"
            };

            // Act
            var response = await _client.PutAsJsonAsync("/api/notes/1", updateDto);

            // Assert
            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized); // No valid JWT
        }

        // Delete Note Tests
        [Test]
        public async Task DeleteNote_ValidId_ReturnsSuccess()
        {
            // Act
            var response = await _client.DeleteAsync("/api/notes/1");

            // Assert
            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized); // No valid JWT
        }

        // Search Notes Tests
        [Test]
        public async Task SearchNotes_ValidQuery_ReturnsResults()
        {
            // Act
            var response = await _client.GetAsync("/api/notes/search?query=test");

            // Assert
            response.StatusCode.Should().Be(HttpStatusCode.Unauthorized); // No valid JWT
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\Testing\Services\AuthServiceTests.cs ==========
// ========================================
// FILE: Testing/Services/AuthServiceTests.cs
// ========================================
using BusinessLayer.Exceptions;
using BusinessLayer.Services;
using DataBaseLayer.Entities;
using DataBaseLayer.Interfaces;
using FluentAssertions;
using ModelLayer.DTOs.Auth;
using Moq;
using NUnit.Framework;

namespace Testing.Services
{
    [TestFixture]
    public class AuthServiceTests
    {
        private Mock<IUserRepository> _userRepositoryMock = null!;
        private AuthService _authService = null!;

        [SetUp]
        public void Setup()
        {
            _userRepositoryMock = new Mock<IUserRepository>();
            _authService = new AuthService(_userRepositoryMock.Object);
        }

        [Test]
        public async Task RegisterAsync_ValidUser_ReturnsOtp()
        {
            var dto = new RegisterRequestDto
            {
                Name = "Test User",
                Email = "test@example.com",
                Password = "Test123"
            };

            _userRepositoryMock.Setup(x => x.GetByEmailAsync(dto.Email))
                .ReturnsAsync((User?)null);

            _userRepositoryMock.Setup(x => x.AddAsync(It.IsAny<User>()))
                .Returns(Task.CompletedTask);

            _userRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            var result = await _authService.RegisterAsync(dto);

            result.Should().NotBeNullOrEmpty();
            result.Should().HaveLength(6);
            result.Should().MatchRegex(@"^\d{6}$");
            _userRepositoryMock.Verify(x => x.AddAsync(It.IsAny<User>()), Times.Once);
            _userRepositoryMock.Verify(x => x.SaveAsync(), Times.Once);
        }

        [Test]
        public async Task RegisterAsync_DuplicateEmail_ThrowsValidationException()
        {
            var dto = new RegisterRequestDto
            {
                Name = "Test User",
                Email = "existing@example.com",
                Password = "Test123"
            };

            var existingUser = new User { Id = 1, Email = dto.Email };
            _userRepositoryMock.Setup(x => x.GetByEmailAsync(dto.Email))
                .ReturnsAsync(existingUser);

            Func<Task> act = async () => await _authService.RegisterAsync(dto);
            await act.Should().ThrowAsync<ValidationException>()
                .WithMessage("User with this email already exists");
        }

        [Test]
        public async Task RegisterAsync_InvalidName_ThrowsValidationException()
        {
            var dto = new RegisterRequestDto
            {
                Name = "A",
                Email = "test@example.com",
                Password = "Test123"
            };

            Func<Task> act = async () => await _authService.RegisterAsync(dto);
            await act.Should().ThrowAsync<ValidationException>();
        }

        [Test]
        public async Task RegisterAsync_InvalidPassword_ThrowsValidationException()
        {
            var dto = new RegisterRequestDto
            {
                Name = "Test User",
                Email = "test@example.com",
                Password = "weak"
            };

            Func<Task> act = async () => await _authService.RegisterAsync(dto);
            await act.Should().ThrowAsync<ValidationException>();
        }

        [Test]
        public async Task VerifyOtpAsync_ValidOtp_VerifiesEmail()
        {
            var email = "test@example.com";
            var otp = "123456";
            var user = new User
            {
                Id = 1,
                Email = email,
                EmailVerificationToken = otp,
                EmailVerificationExpiry = DateTime.UtcNow.AddMinutes(5),
                IsEmailVerified = false
            };

            _userRepositoryMock.Setup(x => x.GetByEmailAsync(email))
                .ReturnsAsync(user);

            _userRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            await _authService.VerifyOtpAsync(email, otp);

            user.IsEmailVerified.Should().BeTrue();
            user.EmailVerificationToken.Should().BeNull();
            user.EmailVerificationExpiry.Should().BeNull();
            _userRepositoryMock.Verify(x => x.SaveAsync(), Times.Once);
        }

        [Test]
        public async Task VerifyOtpAsync_InvalidOtp_ThrowsValidationException()
        {
            var email = "test@example.com";
            var user = new User
            {
                Email = email,
                EmailVerificationToken = "123456",
                EmailVerificationExpiry = DateTime.UtcNow.AddMinutes(5)
            };

            _userRepositoryMock.Setup(x => x.GetByEmailAsync(email))
                .ReturnsAsync(user);

            Func<Task> act = async () => await _authService.VerifyOtpAsync(email, "999999");
            await act.Should().ThrowAsync<ValidationException>()
                .WithMessage("Invalid OTP");
        }

        [Test]
        public async Task VerifyOtpAsync_ExpiredOtp_ThrowsValidationException()
        {
            var email = "test@example.com";
            var user = new User
            {
                Email = email,
                EmailVerificationToken = "123456",
                EmailVerificationExpiry = DateTime.UtcNow.AddMinutes(-5)
            };

            _userRepositoryMock.Setup(x => x.GetByEmailAsync(email))
                .ReturnsAsync(user);

            Func<Task> act = async () => await _authService.VerifyOtpAsync(email, "123456");
            await act.Should().ThrowAsync<ValidationException>()
                .WithMessage("OTP has expired");
        }

        [Test]
        public async Task LoginAsync_ValidCredentials_ReturnsAuthResponse()
        {
            var dto = new LoginRequestDto
            {
                Email = "test@example.com",
                Password = "Test123"
            };

            var user = new User
            {
                Id = 1,
                Email = dto.Email,
                PasswordHash = BCrypt.Net.BCrypt.HashPassword(dto.Password),
                IsEmailVerified = true,
                FailedLoginAttempts = 0
            };

            _userRepositoryMock.Setup(x => x.GetByEmailAsync(dto.Email))
                .ReturnsAsync(user);

            _userRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            var result = await _authService.LoginAsync(dto);

            result.Should().NotBeNull();
            result.UserId.Should().Be(user.Id);
            result.Email.Should().Be(user.Email);
            result.RefreshToken.Should().NotBeNullOrEmpty();
            user.FailedLoginAttempts.Should().Be(0);
        }

        [Test]
        public async Task LoginAsync_InvalidPassword_ThrowsUnauthorizedException()
        {
            var dto = new LoginRequestDto
            {
                Email = "test@example.com",
                Password = "WrongPassword"
            };

            var user = new User
            {
                Email = dto.Email,
                PasswordHash = BCrypt.Net.BCrypt.HashPassword("CorrectPassword123"),
                IsEmailVerified = true
            };

            _userRepositoryMock.Setup(x => x.GetByEmailAsync(dto.Email))
                .ReturnsAsync(user);

            Func<Task> act = async () => await _authService.LoginAsync(dto);
            await act.Should().ThrowAsync<UnauthorizedException>()
                .WithMessage("Invalid credentials");
        }

        [Test]
        public async Task LoginAsync_UnverifiedEmail_ThrowsUnauthorizedException()
        {
            var dto = new LoginRequestDto
            {
                Email = "test@example.com",
                Password = "Test123"
            };

            var user = new User
            {
                Email = dto.Email,
                PasswordHash = BCrypt.Net.BCrypt.HashPassword(dto.Password),
                IsEmailVerified = false
            };

            _userRepositoryMock.Setup(x => x.GetByEmailAsync(dto.Email))
                .ReturnsAsync(user);

            Func<Task> act = async () => await _authService.LoginAsync(dto);
            await act.Should().ThrowAsync<UnauthorizedException>()
                .WithMessage("Email not verified. Please verify your email first");
        }

        [Test]
        public async Task LoginAsync_AccountLocked_ThrowsUnauthorizedException()
        {
            var dto = new LoginRequestDto
            {
                Email = "test@example.com",
                Password = "Test123"
            };

            var user = new User
            {
                Email = dto.Email,
                PasswordHash = BCrypt.Net.BCrypt.HashPassword(dto.Password),
                IsEmailVerified = true,
                LockoutEnd = DateTime.UtcNow.AddMinutes(10)
            };

            _userRepositoryMock.Setup(x => x.GetByEmailAsync(dto.Email))
                .ReturnsAsync(user);

            Func<Task> act = async () => await _authService.LoginAsync(dto);
            await act.Should().ThrowAsync<UnauthorizedException>();
        }

        [Test]
        public async Task RefreshTokenAsync_ValidToken_ReturnsNewAuthResponse()
        {
            var refreshToken = "valid-refresh-token";
            var user = new User
            {
                Id = 1,
                Email = "test@example.com",
                RefreshToken = refreshToken,
                RefreshTokenExpiry = DateTime.UtcNow.AddDays(7)
            };

            _userRepositoryMock.Setup(x => x.GetByRefreshTokenAsync(refreshToken))
                .ReturnsAsync(user);

            _userRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            var result = await _authService.RefreshTokenAsync(refreshToken);

            result.Should().NotBeNull();
            result.UserId.Should().Be(user.Id);
            result.RefreshToken.Should().NotBeNullOrEmpty();
            result.RefreshToken.Should().NotBe(refreshToken);
        }

        [Test]
        public async Task RefreshTokenAsync_ExpiredToken_ThrowsUnauthorizedException()
        {
            var refreshToken = "expired-refresh-token";
            var user = new User
            {
                RefreshToken = refreshToken,
                RefreshTokenExpiry = DateTime.UtcNow.AddDays(-1)
            };

            _userRepositoryMock.Setup(x => x.GetByRefreshTokenAsync(refreshToken))
                .ReturnsAsync(user);

            Func<Task> act = async () => await _authService.RefreshTokenAsync(refreshToken);
            await act.Should().ThrowAsync<UnauthorizedException>()
                .WithMessage("Refresh token has expired");
        }

        [Test]
        public async Task LogoutAsync_ValidUser_ClearsRefreshToken()
        {
            var userId = 1;
            var user = new User
            {
                Id = userId,
                RefreshToken = "some-token",
                RefreshTokenExpiry = DateTime.UtcNow.AddDays(7)
            };

            _userRepositoryMock.Setup(x => x.GetByIdAsync(userId))
                .ReturnsAsync(user);

            _userRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            await _authService.LogoutAsync(userId);

            user.RefreshToken.Should().BeNull();
            user.RefreshTokenExpiry.Should().BeNull();
            _userRepositoryMock.Verify(x => x.SaveAsync(), Times.Once);
        }

        [Test]
        public async Task ForgotPasswordAsync_ValidEmail_GeneratesResetToken()
        {
            var email = "test@example.com";
            var user = new User
            {
                Id = 1,
                Email = email
            };

            _userRepositoryMock.Setup(x => x.GetByEmailAsync(email))
                .ReturnsAsync(user);

            _userRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            await _authService.ForgotPasswordAsync(email);

            user.PasswordResetToken.Should().NotBeNullOrEmpty();
            user.PasswordResetExpiry.Should().NotBeNull();
            _userRepositoryMock.Verify(x => x.SaveAsync(), Times.Once);
        }

        [Test]
        public async Task ForgotPasswordAsync_NonExistentEmail_DoesNotThrow()
        {
            var email = "nonexistent@example.com";

            _userRepositoryMock.Setup(x => x.GetByEmailAsync(email))
                .ReturnsAsync((User?)null);

            Func<Task> act = async () => await _authService.ForgotPasswordAsync(email);

            await act.Should().NotThrowAsync();
        }

        [Test]
        public async Task ResetPasswordAsync_ValidToken_ResetsPassword()
        {
            var token = "valid-reset-token";
            var newPassword = "NewSecure123";
            var user = new User
            {
                Id = 1,
                Email = "test@example.com",
                PasswordResetToken = token,
                PasswordResetExpiry = DateTime.UtcNow.AddMinutes(15),
                PasswordHash = BCrypt.Net.BCrypt.HashPassword("OldPassword123")
            };

            var dto = new ResetPasswordDto
            {
                Token = token,
                NewPassword = newPassword
            };

            _userRepositoryMock.Setup(x => x.GetByResetTokenAsync(token))
                .ReturnsAsync(user);

            _userRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            await _authService.ResetPasswordAsync(dto);

            user.PasswordResetToken.Should().BeNull();
            user.PasswordResetExpiry.Should().BeNull();
            BCrypt.Net.BCrypt.Verify(newPassword, user.PasswordHash).Should().BeTrue();
            _userRepositoryMock.Verify(x => x.SaveAsync(), Times.Once);
        }

        [Test]
        public async Task ResetPasswordAsync_ExpiredToken_ThrowsValidationException()
        {
            var token = "expired-token";
            var user = new User
            {
                PasswordResetToken = token,
                PasswordResetExpiry = DateTime.UtcNow.AddMinutes(-15)
            };

            var dto = new ResetPasswordDto
            {
                Token = token,
                NewPassword = "NewSecure123"
            };

            _userRepositoryMock.Setup(x => x.GetByResetTokenAsync(token))
                .ReturnsAsync(user);

            Func<Task> act = async () => await _authService.ResetPasswordAsync(dto);
            await act.Should().ThrowAsync<ValidationException>()
                .WithMessage("Password reset token has expired");
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\Testing\Services\CollaboratorServiceTests.cs ==========
// ========================================
// FILE: Testing/Services/CollaboratorServiceTests.cs (COMPLETE)
// ========================================
using BusinessLayer.Exceptions;
using BusinessLayer.Services;
using DataBaseLayer.Entities;
using DataBaseLayer.Interfaces;
using FluentAssertions;
using ModelLayer.DTOs.Collaborators;
using ModelLayer.Enums;
using Moq;
using NUnit.Framework;

namespace Testing.Services
{
    [TestFixture]
    public class CollaboratorServiceTests
    {
        private Mock<ICollaboratorRepository> _collaboratorRepositoryMock = null!;
        private Mock<INoteRepository> _noteRepositoryMock = null!;
        private Mock<IUserRepository> _userRepositoryMock = null!;
        private CollaboratorService _collaboratorService = null!;

        [SetUp]
        public void Setup()
        {
            _collaboratorRepositoryMock = new Mock<ICollaboratorRepository>();
            _noteRepositoryMock = new Mock<INoteRepository>();
            _userRepositoryMock = new Mock<IUserRepository>();
            _collaboratorService = new CollaboratorService(
                _collaboratorRepositoryMock.Object,
                _noteRepositoryMock.Object,
                _userRepositoryMock.Object);
        }

        [Test]
        public async Task AddAsync_ValidCollaborator_ReturnsCollaboratorResponse()
        {
            var dto = new AddCollaboratorDto
            {
                NoteId = 1,
                UserId = 2,
                Permission = PermissionLevel.Edit
            };
            var ownerUserId = 1;

            var note = new Note { Id = 1, UserId = ownerUserId };
            var collaboratorUser = new User { Id = 2, Email = "collaborator@example.com" };

            _noteRepositoryMock.Setup(x => x.GetByIdAsync(dto.NoteId))
                .ReturnsAsync(note);

            _userRepositoryMock.Setup(x => x.GetByIdAsync(dto.UserId))
                .ReturnsAsync(collaboratorUser);

            _collaboratorRepositoryMock.Setup(x => x.ExistsAsync(dto.NoteId, dto.UserId))
                .ReturnsAsync(false);

            _collaboratorRepositoryMock.Setup(x => x.AddAsync(It.IsAny<Collaborator>()))
                .Returns(Task.CompletedTask);

            _collaboratorRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            var result = await _collaboratorService.AddAsync(dto, ownerUserId);

            result.Should().NotBeNull();
            result.NoteId.Should().Be(dto.NoteId);
            result.UserId.Should().Be(dto.UserId);
            result.UserEmail.Should().Be(collaboratorUser.Email);
            result.Permission.Should().Be(dto.Permission);
        }

        [Test]
        public async Task AddAsync_NoteNotFound_ThrowsNotFoundException()
        {
            var dto = new AddCollaboratorDto { NoteId = 999, UserId = 2 };
            var ownerUserId = 1;

            _noteRepositoryMock.Setup(x => x.GetByIdAsync(dto.NoteId))
                .ReturnsAsync((Note?)null);

            Func<Task> act = async () => await _collaboratorService.AddAsync(dto, ownerUserId);
            await act.Should().ThrowAsync<NotFoundException>()
                .WithMessage("Note not found");
        }

        [Test]
        public async Task AddAsync_NotOwner_ThrowsUnauthorizedException()
        {
            var dto = new AddCollaboratorDto { NoteId = 1, UserId = 2 };
            var ownerUserId = 1;
            var otherUserId = 3;

            var note = new Note { Id = 1, UserId = ownerUserId };

            _noteRepositoryMock.Setup(x => x.GetByIdAsync(dto.NoteId))
                .ReturnsAsync(note);

            Func<Task> act = async () => await _collaboratorService.AddAsync(dto, otherUserId);
            await act.Should().ThrowAsync<UnauthorizedException>()
                .WithMessage("Only the note owner can add collaborators");
        }

        [Test]
        public async Task AddAsync_AddSelfAsCollaborator_ThrowsValidationException()
        {
            var dto = new AddCollaboratorDto { NoteId = 1, UserId = 1 };
            var ownerUserId = 1;

            var note = new Note { Id = 1, UserId = ownerUserId };

            _noteRepositoryMock.Setup(x => x.GetByIdAsync(dto.NoteId))
                .ReturnsAsync(note);

            Func<Task> act = async () => await _collaboratorService.AddAsync(dto, ownerUserId);
            await act.Should().ThrowAsync<ValidationException>()
                .WithMessage("Cannot add yourself as a collaborator");
        }

        [Test]
        public async Task AddAsync_CollaboratorUserNotFound_ThrowsNotFoundException()
        {
            var dto = new AddCollaboratorDto { NoteId = 1, UserId = 999 };
            var ownerUserId = 1;

            var note = new Note { Id = 1, UserId = ownerUserId };

            _noteRepositoryMock.Setup(x => x.GetByIdAsync(dto.NoteId))
                .ReturnsAsync(note);

            _userRepositoryMock.Setup(x => x.GetByIdAsync(dto.UserId))
                .ReturnsAsync((User?)null);

            Func<Task> act = async () => await _collaboratorService.AddAsync(dto, ownerUserId);
            await act.Should().ThrowAsync<NotFoundException>()
                .WithMessage("Collaborator user not found");
        }

        [Test]
        public async Task AddAsync_DuplicateCollaborator_ThrowsValidationException()
        {
            var dto = new AddCollaboratorDto { NoteId = 1, UserId = 2 };
            var ownerUserId = 1;

            var note = new Note { Id = 1, UserId = ownerUserId };
            var collaboratorUser = new User { Id = 2, Email = "collaborator@example.com" };

            _noteRepositoryMock.Setup(x => x.GetByIdAsync(dto.NoteId))
                .ReturnsAsync(note);

            _userRepositoryMock.Setup(x => x.GetByIdAsync(dto.UserId))
                .ReturnsAsync(collaboratorUser);

            _collaboratorRepositoryMock.Setup(x => x.ExistsAsync(dto.NoteId, dto.UserId))
                .ReturnsAsync(true);

            Func<Task> act = async () => await _collaboratorService.AddAsync(dto, ownerUserId);
            await act.Should().ThrowAsync<ValidationException>()
                .WithMessage("This user is already a collaborator on this note");
        }

        [Test]
        public async Task GetByNoteIdAsync_ValidNote_ReturnsCollaborators()
        {
            var noteId = 1;
            var userId = 1;
            var note = new Note { Id = noteId, UserId = userId };

            var collaborators = new List<Collaborator>
            {
                new Collaborator
                {
                    Id = 1,
                    NoteId = noteId,
                    CollaboratorId = 2,
                    CollaboratorUser = new User { Id = 2, Email = "user2@example.com" },
                    Permission = DataBaseLayer.Enums.PermissionLevel.View,
                    CreatedAt = DateTime.UtcNow
                }
            };

            _noteRepositoryMock.Setup(x => x.GetByIdAsync(noteId))
                .ReturnsAsync(note);

            _collaboratorRepositoryMock.Setup(x => x.GetByNoteIdAsync(noteId))
                .ReturnsAsync(collaborators);

            var result = await _collaboratorService.GetByNoteIdAsync(noteId, userId);

            result.Should().HaveCount(1);
            result.First().UserEmail.Should().Be("user2@example.com");
        }

        [Test]
        public async Task GetByNoteIdAsync_NotOwnerOrCollaborator_ThrowsUnauthorizedException()
        {
            var noteId = 1;
            var ownerId = 1;
            var otherUserId = 3;

            var note = new Note { Id = noteId, UserId = ownerId };

            _noteRepositoryMock.Setup(x => x.GetByIdAsync(noteId))
                .ReturnsAsync(note);

            _collaboratorRepositoryMock.Setup(x => x.ExistsAsync(noteId, otherUserId))
                .ReturnsAsync(false);

            Func<Task> act = async () => await _collaboratorService.GetByNoteIdAsync(noteId, otherUserId);
            await act.Should().ThrowAsync<UnauthorizedException>()
                .WithMessage("Access denied");
        }

        [Test]
        public async Task UpdatePermissionAsync_ValidUpdate_ReturnsUpdatedCollaborator()
        {
            var collaboratorId = 1;
            var ownerUserId = 1;
            var dto = new UpdatePermissionDto { Permission = PermissionLevel.Edit };

            var collaborator = new Collaborator
            {
                Id = collaboratorId,
                NoteId = 1,
                CollaboratorId = 2,
                CollaboratorUser = new User { Email = "collaborator@example.com" },
                Permission = DataBaseLayer.Enums.PermissionLevel.View,
                CreatedAt = DateTime.UtcNow
            };

            var note = new Note { Id = 1, UserId = ownerUserId };

            _collaboratorRepositoryMock.Setup(x => x.GetByIdWithUserAsync(collaboratorId))
                .ReturnsAsync(collaborator);

            _noteRepositoryMock.Setup(x => x.GetByIdAsync(collaborator.NoteId))
                .ReturnsAsync(note);

            _collaboratorRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            var result = await _collaboratorService.UpdatePermissionAsync(collaboratorId, dto, ownerUserId);

            result.Should().NotBeNull();
            result.Permission.Should().Be(dto.Permission);
            collaborator.Permission.Should().Be(DataBaseLayer.Enums.PermissionLevel.Edit);
        }

        [Test]
        public async Task UpdatePermissionAsync_NotOwner_ThrowsUnauthorizedException()
        {
            var collaboratorId = 1;
            var ownerUserId = 1;
            var otherUserId = 3;
            var dto = new UpdatePermissionDto { Permission = PermissionLevel.Edit };

            var collaborator = new Collaborator
            {
                Id = collaboratorId,
                NoteId = 1,
                CollaboratorId = 2
            };

            var note = new Note { Id = 1, UserId = ownerUserId };

            _collaboratorRepositoryMock.Setup(x => x.GetByIdWithUserAsync(collaboratorId))
                .ReturnsAsync(collaborator);

            _noteRepositoryMock.Setup(x => x.GetByIdAsync(collaborator.NoteId))
                .ReturnsAsync(note);

            Func<Task> act = async () => await _collaboratorService.UpdatePermissionAsync(collaboratorId, dto, otherUserId);
            await act.Should().ThrowAsync<UnauthorizedException>()
                .WithMessage("Only the note owner can update permissions");
        }

        [Test]
        public async Task RemoveAsync_ValidCollaborator_RemovesCollaborator()
        {
            var collaboratorId = 1;
            var ownerUserId = 1;

            var collaborator = new Collaborator
            {
                Id = collaboratorId,
                NoteId = 1,
                CollaboratorId = 2
            };

            var note = new Note { Id = 1, UserId = ownerUserId };

            _collaboratorRepositoryMock.Setup(x => x.GetByIdAsync(collaboratorId))
                .ReturnsAsync(collaborator);

            _noteRepositoryMock.Setup(x => x.GetByIdAsync(collaborator.NoteId))
                .ReturnsAsync(note);

            _collaboratorRepositoryMock.Setup(x => x.DeleteAsync(collaborator))
                .Returns(Task.CompletedTask);

            _collaboratorRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            await _collaboratorService.RemoveAsync(collaboratorId, ownerUserId);

            _collaboratorRepositoryMock.Verify(x => x.DeleteAsync(collaborator), Times.Once);
            _collaboratorRepositoryMock.Verify(x => x.SaveAsync(), Times.Once);
        }

        [Test]
        public async Task RemoveAsync_CollaboratorNotFound_ThrowsNotFoundException()
        {
            var collaboratorId = 999;
            var ownerUserId = 1;

            _collaboratorRepositoryMock.Setup(x => x.GetByIdAsync(collaboratorId))
                .ReturnsAsync((Collaborator?)null);

            Func<Task> act = async () => await _collaboratorService.RemoveAsync(collaboratorId, ownerUserId);
            await act.Should().ThrowAsync<NotFoundException>()
                .WithMessage("Collaborator not found");
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\Testing\Services\LabelServiceTests.cs ==========
// ========================================
// FILE: Testing/Services/LabelServiceTests.cs
// ========================================
using BusinessLayer.Exceptions;
using BusinessLayer.Services;
using DataBaseLayer.Entities;
using DataBaseLayer.Interfaces;
using FluentAssertions;
using ModelLayer.DTOs.Labels;
using Moq;
using NUnit.Framework;

namespace Testing.Services
{
    [TestFixture]
    public class LabelServiceTests
    {
        private Mock<ILabelRepository> _labelRepositoryMock = null!;
        private LabelService _labelService = null!;

        [SetUp]
        public void Setup()
        {
            _labelRepositoryMock = new Mock<ILabelRepository>();
            _labelService = new LabelService(_labelRepositoryMock.Object);
        }

        [Test]
        public async Task CreateAsync_ValidLabel_ReturnsLabelResponse()
        {
            var dto = new CreateLabelDto { Name = "Work" };
            var userId = 1;

            _labelRepositoryMock.Setup(x => x.ExistsForUserAsync(dto.Name, userId, null))
                .ReturnsAsync(false);

            _labelRepositoryMock.Setup(x => x.AddAsync(It.IsAny<Label>()))
                .Returns(Task.CompletedTask);

            _labelRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            var result = await _labelService.CreateAsync(dto, userId);

            result.Should().NotBeNull();
            result.Name.Should().Be(dto.Name);
            _labelRepositoryMock.Verify(x => x.AddAsync(It.IsAny<Label>()), Times.Once);
        }

        [Test]
        public async Task CreateAsync_DuplicateName_ThrowsValidationException()
        {
            var dto = new CreateLabelDto { Name = "Work" };
            var userId = 1;

            _labelRepositoryMock.Setup(x => x.ExistsForUserAsync(dto.Name, userId, null))
                .ReturnsAsync(true);

            Func<Task> act = async () => await _labelService.CreateAsync(dto, userId);
            await act.Should().ThrowAsync<ValidationException>()
                .WithMessage("A label with this name already exists");
        }

        [Test]
        public async Task CreateAsync_EmptyName_ThrowsValidationException()
        {
            var dto = new CreateLabelDto { Name = "" };
            var userId = 1;

            Func<Task> act = async () => await _labelService.CreateAsync(dto, userId);
            await act.Should().ThrowAsync<ValidationException>()
                .WithMessage("Label name is required");
        }

        [Test]
        public async Task GetByUserAsync_UserHasLabels_ReturnsAllLabels()
        {
            var userId = 1;
            var labels = new List<Label>
            {
                new Label { Id = 1, Name = "Work", UserId = userId, CreatedAt = DateTime.UtcNow },
                new Label { Id = 2, Name = "Personal", UserId = userId, CreatedAt = DateTime.UtcNow }
            };

            _labelRepositoryMock.Setup(x => x.GetByUserAsync(userId))
                .ReturnsAsync(labels);

            var result = await _labelService.GetByUserAsync(userId);

            result.Should().HaveCount(2);
            result.Should().Contain(l => l.Name == "Work");
            result.Should().Contain(l => l.Name == "Personal");
        }

        [Test]
        public async Task GetByIdAsync_ValidLabel_ReturnsLabel()
        {
            var labelId = 1;
            var userId = 1;
            var label = new Label
            {
                Id = labelId,
                Name = "Work",
                UserId = userId,
                CreatedAt = DateTime.UtcNow
            };

            _labelRepositoryMock.Setup(x => x.GetByIdAsync(labelId))
                .ReturnsAsync(label);

            var result = await _labelService.GetByIdAsync(labelId, userId);

            result.Should().NotBeNull();
            result!.Id.Should().Be(labelId);
            result.Name.Should().Be(label.Name);
        }

        [Test]
        public async Task UpdateAsync_ValidUpdate_ReturnsUpdatedLabel()
        {
            var labelId = 1;
            var userId = 1;
            var label = new Label
            {
                Id = labelId,
                Name = "Old Name",
                UserId = userId,
                CreatedAt = DateTime.UtcNow
            };

            var dto = new UpdateLabelDto { Name = "New Name" };

            _labelRepositoryMock.Setup(x => x.GetByIdAsync(labelId))
                .ReturnsAsync(label);

            _labelRepositoryMock.Setup(x => x.ExistsForUserAsync(dto.Name, userId, labelId))
                .ReturnsAsync(false);

            _labelRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            var result = await _labelService.UpdateAsync(labelId, dto, userId);

            result.Should().NotBeNull();
            result.Name.Should().Be(dto.Name);
            label.Name.Should().Be(dto.Name);
        }

        [Test]
        public async Task DeleteAsync_ValidLabel_DeletesLabel()
        {
            var labelId = 1;
            var userId = 1;
            var label = new Label
            {
                Id = labelId,
                Name = "Work",
                UserId = userId
            };

            _labelRepositoryMock.Setup(x => x.GetByIdAsync(labelId))
                .ReturnsAsync(label);

            _labelRepositoryMock.Setup(x => x.DeleteAsync(label))
                .Returns(Task.CompletedTask);

            _labelRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            await _labelService.DeleteAsync(labelId, userId);

            _labelRepositoryMock.Verify(x => x.DeleteAsync(label), Times.Once);
            _labelRepositoryMock.Verify(x => x.SaveAsync(), Times.Once);
        }
    }
}

========== FILE: C:\Users\KOTIPALLI SRIKESH\source\repos\FundooNotes\Testing\Services\NoteServiceTests.cs ==========
// ========================================
// FILE: Testing/Services/NoteServiceTests.cs
// ========================================
using BusinessLayer.Exceptions;
using BusinessLayer.Services;
using DataBaseLayer.Entities;
using DataBaseLayer.Interfaces;
using FluentAssertions;
using ModelLayer.DTOs.Notes;
using Moq;
using NUnit.Framework;

namespace Testing.Services
{
    [TestFixture]
    public class NoteServiceTests
    {
        private Mock<INoteRepository> _noteRepositoryMock = null!;
        private Mock<ICollaboratorRepository> _collaboratorRepositoryMock = null!;
        private NoteService _noteService = null!;

        [SetUp]
        public void Setup()
        {
            _noteRepositoryMock = new Mock<INoteRepository>();
            _collaboratorRepositoryMock = new Mock<ICollaboratorRepository>();
            _noteService = new NoteService(_noteRepositoryMock.Object, _collaboratorRepositoryMock.Object);
        }

        [Test]
        public async Task CreateAsync_ValidNote_ReturnsNoteResponse()
        {
            var dto = new CreateNoteDto
            {
                Title = "Test Note",
                Content = "Test Content",
                Color = "#FFFFFF"
            };
            var userId = 1;

            _noteRepositoryMock.Setup(x => x.AddAsync(It.IsAny<Note>()))
                .Returns(Task.CompletedTask);

            _noteRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            var result = await _noteService.CreateAsync(dto, userId);

            result.Should().NotBeNull();
            result.Title.Should().Be(dto.Title);
            result.Content.Should().Be(dto.Content);
            result.Color.Should().Be(dto.Color);
            _noteRepositoryMock.Verify(x => x.AddAsync(It.IsAny<Note>()), Times.Once);
        }

        [Test]
        public async Task CreateAsync_EmptyTitleAndContent_ThrowsValidationException()
        {
            var dto = new CreateNoteDto { Title = "", Content = "" };
            var userId = 1;

            Func<Task> act = async () => await _noteService.CreateAsync(dto, userId);
            await act.Should().ThrowAsync<ValidationException>()
                .WithMessage("Either title or content is required");
        }

        [Test]
        public async Task CreateAsync_InvalidColor_ThrowsValidationException()
        {
            var dto = new CreateNoteDto
            {
                Title = "Test",
                Color = "#GGGGGG"
            };
            var userId = 1;

            Func<Task> act = async () => await _noteService.CreateAsync(dto, userId);
            await act.Should().ThrowAsync<ValidationException>();
        }

        [Test]
        public async Task GetByIdAsync_ValidNote_ReturnsNote()
        {
            var noteId = 1;
            var userId = 1;
            var note = new Note
            {
                Id = noteId,
                UserId = userId,
                Title = "Test",
                Content = "Content",
                Color = "#FFFFFF",
                IsDeleted = false
            };

            _noteRepositoryMock.Setup(x => x.GetByIdAsync(noteId))
                .ReturnsAsync(note);

            var result = await _noteService.GetByIdAsync(noteId, userId);

            result.Should().NotBeNull();
            result!.Id.Should().Be(noteId);
            result.Title.Should().Be(note.Title);
        }

        [Test]
        public async Task GetByIdAsync_UnauthorizedUser_ThrowsUnauthorizedException()
        {
            var noteId = 1;
            var ownerId = 1;
            var otherUserId = 2;
            var note = new Note
            {
                Id = noteId,
                UserId = ownerId,
                IsDeleted = false
            };

            _noteRepositoryMock.Setup(x => x.GetByIdAsync(noteId))
                .ReturnsAsync(note);

            _collaboratorRepositoryMock.Setup(x => x.ExistsAsync(noteId, otherUserId))
                .ReturnsAsync(false);

            Func<Task> act = async () => await _noteService.GetByIdAsync(noteId, otherUserId);
            await act.Should().ThrowAsync<UnauthorizedException>();
        }

        [Test]
        public async Task UpdateAsync_ValidUpdate_ReturnsUpdatedNote()
        {
            var noteId = 1;
            var userId = 1;
            var note = new Note
            {
                Id = noteId,
                UserId = userId,
                Title = "Old Title",
                Content = "Old Content"
            };

            var dto = new UpdateNoteDto
            {
                Title = "New Title",
                Content = "New Content"
            };

            _noteRepositoryMock.Setup(x => x.GetByIdAsync(noteId))
                .ReturnsAsync(note);

            _noteRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            var result = await _noteService.UpdateAsync(noteId, dto, userId);

            result.Should().NotBeNull();
            result.Title.Should().Be(dto.Title);
            result.Content.Should().Be(dto.Content);
        }

        [Test]
        public async Task UpdateAsync_NoteNotFound_ThrowsNotFoundException()
        {
            var noteId = 999;
            var userId = 1;
            var dto = new UpdateNoteDto { Title = "New" };

            _noteRepositoryMock.Setup(x => x.GetByIdAsync(noteId))
                .ReturnsAsync((Note?)null);

            Func<Task> act = async () => await _noteService.UpdateAsync(noteId, dto, userId);
            await act.Should().ThrowAsync<NotFoundException>();
        }

        [Test]
        public async Task DeleteAsync_ValidNote_SoftDeletesNote()
        {
            var noteId = 1;
            var userId = 1;
            var note = new Note
            {
                Id = noteId,
                UserId = userId,
                IsDeleted = false
            };

            _noteRepositoryMock.Setup(x => x.GetByIdAsync(noteId))
                .ReturnsAsync(note);

            _noteRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            await _noteService.DeleteAsync(noteId, userId);

            note.IsDeleted.Should().BeTrue();
            note.DeletedAt.Should().NotBeNull();
        }

        [Test]
        public async Task TogglePinAsync_ValidNote_TogglesPin()
        {
            var noteId = 1;
            var userId = 1;
            var note = new Note
            {
                Id = noteId,
                UserId = userId,
                IsPinned = false
            };

            _noteRepositoryMock.Setup(x => x.GetByIdAsync(noteId))
                .ReturnsAsync(note);

            _noteRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            var result = await _noteService.TogglePinAsync(noteId, userId);

            result.IsPinned.Should().BeTrue();
            note.IsPinned.Should().BeTrue();
        }

        [Test]
        public async Task SearchAsync_ValidQuery_ReturnsMatchingNotes()
        {
            var userId = 1;
            var query = "test";
            var notes = new List<Note>
            {
                new Note { Id = 1, UserId = userId, Title = "Test Note 1" },
                new Note { Id = 2, UserId = userId, Content = "Contains test" }
            };

            var dto = new SearchNotesDto { Query = query };

            _noteRepositoryMock.Setup(x => x.SearchAsync(query, userId))
                .ReturnsAsync(notes);

            var result = await _noteService.SearchAsync(dto, userId);

            result.Should().HaveCount(2);
        }

        [Test]
        public async Task BulkDeleteAsync_ValidIds_DeletesMultipleNotes()
        {
            var userId = 1;
            var noteIds = new List<int> { 1, 2, 3 };
            var notes = noteIds.Select(id => new Note
            {
                Id = id,
                UserId = userId,
                IsDeleted = false
            }).ToList();

            var dto = new BulkDeleteDto { NoteIds = noteIds };

            _noteRepositoryMock.Setup(x => x.GetByIdsAsync(noteIds))
                .ReturnsAsync(notes);

            _noteRepositoryMock.Setup(x => x.SaveAsync())
                .Returns(Task.CompletedTask);

            await _noteService.BulkDeleteAsync(dto, userId);

            notes.Should().AllSatisfy(n => n.IsDeleted.Should().BeTrue());
        }
    }
}
